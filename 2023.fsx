#r "nuget: FParsec"

open System

[<AutoOpen>]
module Util =

    [<RequireQualifiedAccess>]
    module Math =

        let integerPower base' exponent =
            if exponent < 0 then
                invalidArg (nameof(exponent)) $"exponent must be at least 0; given %i{exponent}"
            else
                Seq.replicate exponent base'
                |> Seq.fold (*) 1

        /// Returns the greatest common divisor of a and b.
        let gcd a b =
            // Implements Euclid's algorithm.
            let rec inner a b = if b = 0UL then a else inner b (a % b)
            inner a b

        /// Returns the least common multiple of a and b.
        let lcm a b = (a * b) / gcd a b

    [<RequireQualifiedAccess>]
    module Parser =
        open FParsec

        let runAndUnwrap f parser line =
            match CharParsers.run parser line with
            | Success (x, _, _) -> f x
            | Failure (error, _, _) -> failwith $"Failed to parse line (%s{error}): %s{line}"

    [<RequireQualifiedAccess>]
    module Seq =

        let tryMin xs =
            if Seq.isEmpty xs then None else Some (Seq.min xs)

        let containsRepeats xs = Seq.length (Seq.distinct xs) < Seq.length xs

        /// Returns a sequence up to and including the first element of the input sequence that matches the predicate,
        /// then no more. If there are no matching elements in the input sequence, then all elements will be returned.
        // Implementation inspired by https://stackoverflow.com/a/12564899
        // TODO: add tests.
        let takeUntilFirstMatch predicate (s:seq<_>) =
            let rec loop (en:System.Collections.Generic.IEnumerator<_>) = seq {
                if en.MoveNext() then
                    yield en.Current
                    if not (predicate en.Current) then
                        yield! loop en
            }

            seq {
                use en = s.GetEnumerator()
                yield! loop en
            }

        /// <summary>
        /// Keep generating elements by applying genNext to the previous element, starting with start, until an element
        /// that has already been encountered is generated.
        /// </summary>
        /// <returns>
        /// The subsequence before the repeated element is first encountered, and the subsequence starting from the
        /// first instance of the first repeated element and ending just before it is encountered again.
        /// </returns>
        /// <remarks>
        /// This is useful because it is easy from the returned information to calculate what the nth element will be
        /// without having to apply genNext n times, which is much more efficient if genNext is computationally
        /// expensive or n is very large.
        /// </remarks>
        // TODO: add tests, e.g. (fun n -> if n < 3 then n + 1 else n - 3) 13 should return [ 13; 10; 7; 4 ], [ 1; 2; 3; 0 ]
        let decomposeIntoPreCycleAndCycle genNext start =

            /// Note: elements are in reverse order.
            let untilFirstRepeat =
                ([ start ], Seq.initInfinite ignore)
                ||> Seq.scan
                    (fun previousElements ()  ->
                        if containsRepeats previousElements then
                            previousElements
                        else
                            // Later elements added to the start.
                            (previousElements |> List.head |> genNext) :: previousElements)
                |> Seq.skipWhile (not << containsRepeats)
                |> Seq.head

            let cycleStartElement, rest = List.head untilFirstRepeat, List.tail untilFirstRepeat

            let cycleRev, preCycleRev =
                let cycleRevStartIndex = rest |> List.findIndex ((=) cycleStartElement)
                List.splitAt (cycleRevStartIndex + 1) rest

            preCycleRev |> Seq.rev, cycleRev |> Seq.rev

        /// Returns a function that, given a non-negative integer `n`, gets the nth element of the sequence generated by
        /// repeated application of `genNext` starting with `start`, so long as that sequence eventually falls into a
        /// cycle.
        let repeatingSequenceElementCalculator genNext start =

            let preCycle, cycle =
                decomposeIntoPreCycleAndCycle genNext start
                |> fun (pc, c) -> Seq.toArray pc, Seq.toArray c

            fun n ->
                if n < preCycle.Length then preCycle.[n] else cycle.[ (n - preCycle.Length) % cycle.Length ]

    type Collections.Generic.IDictionary<'a, 'b> with

        member this.TryGet k =
            match this.TryGetValue k with
            | true, v -> Some v
            | false, _ -> None

    let memoize f =
        let cache = Collections.Generic.Dictionary<'key, 'value>()
        fun x -> cache.TryGet x |> Option.defaultWith (fun _ -> x |> f |> fun y -> cache.Add(x, y); y)

    [<RequireQualifiedAccess>]
    module Array2D =

        let row i array2D =
            seq { 0 .. (array2D |> Array2D.length2) - 1 }
            |> Seq.map (fun j -> Array2D.get array2D i j)
            |> Seq.toArray

        let column j array2D =
            seq { 0 .. (array2D |> Array2D.length1) - 1 }
            |> Seq.map (fun i -> Array2D.get array2D i j)
            |> Seq.toArray

        let columns array2D =
            seq { 0 .. (array2D |> Array2D.length2) - 1 }
            |> Seq.map (fun j -> column j array2D)
            |> Seq.toArray

module Day1 =
    module PartOne =
        let solve lines =
            let toCalibrationValue line =
                line
                |> String.filter Char.IsDigit
                |> fun cs -> Int32.Parse $"%c{Seq.head cs}%c{Seq.last cs}"

            lines
            |> Seq.sumBy toCalibrationValue
            |> fun totalCalibration -> printfn $"totalCalibration is %i{totalCalibration}"

    module PartTwo =
        let solve lines =
            let toCalibrationValue (line: string) =
                let digitRepresentations =
                    [
                        "0", 0
                        "1", 1
                        "2", 2
                        "3", 3
                        "4", 4
                        "5", 5
                        "6", 6
                        "7", 7
                        "8", 8
                        "9", 9
                        "one", 1
                        "two", 2
                        "three", 3
                        "four", 4
                        "five", 5
                        "six", 6
                        "seven", 7
                        "eight", 8
                        "nine", 9
                    ]

                let indices =
                    digitRepresentations
                    |> List.map (fun (rep, i) -> i, line.IndexOf rep, line.LastIndexOf rep)

                let firstDigit =
                    indices
                    |> List.filter (fun (_, first, _) -> first >= 0)
                    |> List.minBy (fun (_, first, _) -> first)
                    |> fun (i, _, _) -> i

                let lastDigit =
                    indices
                    |> List.filter (fun (_, last, _) -> last >= 0)
                    |> List.maxBy (fun (_, _, last) -> last)
                    |> fun (i, _, _) -> i

                10 * firstDigit + lastDigit

            lines
            |> Seq.sumBy toCalibrationValue
            |> fun totalCalibration -> printfn $"totalCalibration is %i{totalCalibration}"

module Day2 =
    open FParsec
    type Colour =
        | Red
        | Green
        | Blue

    type Set = {
        RedCount: int
        GreenCount: int
        BlueCount: int
    }

    module Set =
        let colourCount colour set =
            match colour with
            | Red -> set.RedCount
            | Green -> set.GreenCount
            | Blue -> set.BlueCount

    type Game =
        {
            GameId: int
            Sets: Set list
        }
        member this.MaxColourCount colour = this.Sets |> List.map (Set.colourCount colour) |> List.max
        member this.Power = this.MaxColourCount Red * this.MaxColourCount Green * this.MaxColourCount Blue

    let pGameId = pstring "Game " >>. pint32 .>> pstring ": "
    let pColour = stringReturn "red" Red <|> stringReturn "green" Green <|> stringReturn "blue" Blue
    let pColourCount = pint32 .>> pstring " " .>>. pColour
    let pSet = sepBy pColourCount (pstring ", ")
    let pGame = pGameId .>>. sepBy pSet (pstring "; ")
    let parse line =
        match CharParsers.run pGame line with
        | Success ((gameId, sets), _, _) ->
            let sets =
                sets
                |> List.map (fun colourCounts ->
                    let count colour =
                        colourCounts
                        |> List.tryFind (fun (_, c) -> c = colour)
                        |> Option.map fst
                        |> Option.defaultValue 0
                    {
                        RedCount = count Red
                        GreenCount = count Green
                        BlueCount = count Blue
                    })

            { GameId = gameId; Sets = sets }
        | Failure (error, _, _) ->
            failwith $"Failed to parse line (%s{error}): %s{line}"

    module PartOne =
        let solve lines =
            lines
            |> Seq.map parse
            |> Seq.filter (fun game ->
                game.MaxColourCount Red <= 12 &&
                game.MaxColourCount Green <= 13 &&
                game.MaxColourCount Blue <= 14)
            |> Seq.sumBy (fun game -> game.GameId)
            |> fun sumOfGameIds -> printfn $"Sum of game IDs: %i{sumOfGameIds}"

    module PartTwo =
        let solve lines =
            lines
            |> Seq.map parse
            |> Seq.sumBy (fun game -> game.Power)
            |> fun sumOfPowers -> printfn $"Sum of powers is %i{sumOfPowers}"

module Day3 =
    let matchingLocations predicate lines =
        lines
        |> Seq.indexed
        |> Seq.collect (fun (i, line) ->
            line
            |> Seq.indexed
            |> Seq.filter (snd >> predicate)
            |> Seq.map (fun (j, _) -> i, j))

    let numbersWithLocations lines =
        lines
        |> matchingLocations Char.IsDigit
        |> Seq.fold
            (fun (adjacentDigitLists, (lastI, lastJ)) (i,j) ->
                let adjacentDigitLists =
                    let digit = lines |> Seq.item i |> Seq.item j
                    if i = lastI && j = lastJ + 1 then
                        let digitsSoFar, previousNumbers =
                            match adjacentDigitLists with
                            | [] -> [], []
                            | soFar :: previous -> soFar, previous
                        ((digit, (i,j)) :: digitsSoFar) :: previousNumbers
                    else
                        [ (digit, (i,j)) ] :: adjacentDigitLists
                adjacentDigitLists, (i,j)
            )
            ([], (-1, 0))
        |> fst
        |> List.map (
            List.rev
            >> List.unzip
            >> (fun (digits, locations) -> digits |> List.toArray |> Int32.Parse, locations)
        )
        |> List.rev

    let locationsAdjacentTo (i, j) =
        seq {
            (i - 1, j - 1); (i - 1, j); (i - 1, j + 1)
            (i, j - 1);                 (i, j + 1)
            (i + 1, j - 1); (i + 1, j); (i + 1, j + 1)
        }

    module PartOne =
        let solve lines =
            let partNumbers =
                let locationsAdjacentToSymbols =
                    lines
                    |> matchingLocations (fun c -> Char.IsSymbol c || Char.IsPunctuation c && c <> '.')
                    |> Seq.collect locationsAdjacentTo
                    |> Set

                let isAdjacentToSymbol (_, locations) =
                    Set locations
                    |> Set.intersect locationsAdjacentToSymbols
                    |> Set.isEmpty
                    |> not

                lines
                |> numbersWithLocations
                |> List.filter isAdjacentToSymbol
                |> List.map fst

            List.sum partNumbers

    module PartTwo =
        let solve lines =
            let gearRatios =
                let numbersAroundEachAsterisk =
                    let numbersWithLocations = numbersWithLocations lines
                    lines
                    |> matchingLocations (fun c -> c = '*')
                    |> Seq.map (fun asteriskLocation ->
                        let locationsAdjacentToAsterisk = locationsAdjacentTo asteriskLocation |> Set
                        numbersWithLocations
                        |> List.filter (snd >> Set >> Set.intersect locationsAdjacentToAsterisk >> Set.isEmpty >> not)
                        |> List.map fst)

                numbersAroundEachAsterisk
                |> Seq.filter (fun numbers -> numbers.Length = 2)
                |> Seq.map (List.reduce (*))

            Seq.sum gearRatios

module Day4 =
    open FParsec

    type Card =
        {
            Number: int
            WinningNumbers: int Set
            NumbersYouHave: int Set
        }
        member this.MatchingNumberCount =
            Set.intersect this.WinningNumbers this.NumbersYouHave
            |> Set.count

    let pCardNumber = pstring "Card" >>. spaces1 >>. pint32 .>> pstring ":"
    // >>? results in lookahead behaviour, meaning that the '|' won't cause an error.
    // See http://www.quanttec.com/fparsec/users-guide/looking-ahead-and-backtracking.html
    let pNumbers = many (spaces1 >>? pint32)
    let pCard = pCardNumber .>>. pNumbers .>> pstring " |" .>>. pNumbers

    let parse line =
        match CharParsers.run pCard line with
        | Success (((cardNumber, winningNumbers), numbersYouHave), _, _) ->
            {
                Number = cardNumber
                WinningNumbers = Set winningNumbers
                NumbersYouHave = Set numbersYouHave
            }
        | Failure (error, _, _) ->
            failwith $"Failed to parse line (%s{error}): %s{line}"

    module PartOne =
        let solve lines =
            lines
            |> Seq.map parse
            |> Seq.sumBy (fun card ->
                card.MatchingNumberCount
                |> fun count -> if count = 0 then 0 else Math.integerPower 2 (count - 1))

    module PartTwo =
        let solve lines =
            let contributions = Collections.Generic.Dictionary<int,int>()

            lines
            |> Seq.map parse
            // We can determine each card's contribution to the total by working out which copies it produces and using
            // the contributions of later cards. This means that if we go through the sequence backwards then we won't
            // have to keep track of the number of copies of each card, which should be simpler.
            |> Seq.rev
            |> Seq.sumBy (fun card ->
                let copyNumbers = Seq.init card.MatchingNumberCount (fun i -> card.Number + 1 + i)
                let contributionsFromCopies = copyNumbers |> Seq.sumBy (fun num -> contributions.Item num)
                let contribution = 1 + contributionsFromCopies

                contributions.Add(card.Number, contribution)

                contribution)

module Day5 =
    open FParsec

    type Range = {
        DestinationRangeStart: int64
        SourceRangeStart: int64
        RangeLength: int64
    }

    type MapHeader = {
        SourceCategory: string
        DestinationCategory: string
    }

    type Map = {
        Header: MapHeader
        Ranges: Range list
    }

    let pSpace = pchar ' '

    let pMapHeader =
        pipe2
            (many1 letter .>> pstring "-to-")
            (many1 letter .>> pSpace .>> pstring "map:")
            (fun letters letters' -> {
                SourceCategory = String(letters |> List.toArray)
                DestinationCategory = String(letters' |> List.toArray)
            })

    let pRange =
        pipe3 (pint64 .>> pSpace) (pint64 .>> pSpace) pint64 (fun i j k -> {
            DestinationRangeStart = i
            SourceRangeStart = j
            RangeLength = k
        })

    let pMap =
        pipe2
            pMapHeader
            (many (spaces >>? pRange))
            (fun header ranges -> { Header = header; Ranges = ranges })

    let mapsInOrder unorderedMaps =
        List.unfold
            (fun sourceCategory ->
                unorderedMaps
                |> List.tryFind (fun m -> m.Header.SourceCategory = sourceCategory)
                |> Option.map (fun map -> map, map.Header.DestinationCategory))
            "seed"

    let applyMap map (category, x) =
        if category = map.Header.SourceCategory then
            let applicableRange =
                map.Ranges
                |> List.tryFind (fun range ->
                    range.SourceRangeStart <= x && x < range.SourceRangeStart + range.RangeLength)

            match applicableRange with
            | Some range -> (map.Header.DestinationCategory, x + range.DestinationRangeStart - range.SourceRangeStart)
            | None -> (map.Header.DestinationCategory, x)
        else
            (category, x)

    module PartOne =

        type Almanac = {
            Seeds: int64 list
            Maps: Map list
        }

        let pSeeds = pstring "seeds:" >>. many (pSpace >>. pint64)

        let pAlmanac = pipe2 pSeeds (many (spaces1 >>? pMap)) (fun seeds maps -> { Seeds = seeds; Maps = maps })

        let solve text =

            let almanac = Parser.runAndUnwrap id pAlmanac text

            let applyAllMaps =
                almanac.Maps
                |> mapsInOrder
                |> List.map applyMap
                |> List.reduce (>>)

            almanac.Seeds
            |> List.map (fun i -> applyAllMaps ("seed", i))
            |> List.minBy snd

    module PartTwo =

        type SeedRange =
            {
                SeedRangeStart: int64
                SeedRangeLength: int64
            }
            member this.Seeds =
                seq { this.SeedRangeStart .. (this.SeedRangeStart + this.SeedRangeLength - 1L) }

        type Almanac = {
            SeedRanges: SeedRange list
            Maps: Map list
        }

        let pSeeds =
            pstring "seeds:"
            >>. many
                (pipe2
                    (pSpace >>. pint64)
                    (pSpace >>. pint64)
                    (fun i j -> { SeedRangeStart = i; SeedRangeLength = j }))

        let pAlmanac = pipe2 pSeeds (many (spaces1 >>? pMap)) (fun seeds maps -> { SeedRanges = seeds; Maps = maps })

        /// Adds ranges where source values map to the same destination value.
        let includeImplicitRanges map =

            let explicitRanges = map.Ranges

            let implicitRanges =

                let sortedExplicit =
                    explicitRanges
                    |> Seq.sortBy (fun r -> r.SourceRangeStart)
                    |> Seq.toArray

                let before =

                    let firstExplicitRangeStart = sortedExplicit |> Array.head |> fun r -> r.SourceRangeStart

                    if firstExplicitRangeStart = 0L then
                        None
                    else
                        Some {
                            SourceRangeStart = 0L
                            DestinationRangeStart = 0L
                            RangeLength = firstExplicitRangeStart
                        }

                let between =
                    sortedExplicit
                    |> Seq.pairwise
                    |> Seq.map (fun (r1, r2) ->
                        let nextRangeStart = r1.SourceRangeStart + r1.RangeLength
                        if nextRangeStart < r2.SourceRangeStart then
                            Some {
                                SourceRangeStart = nextRangeStart
                                DestinationRangeStart = nextRangeStart
                                RangeLength = r2.SourceRangeStart - nextRangeStart
                            }
                        else
                            None)

                let after =

                    let nextRangeStart =
                        sortedExplicit |> Array.last |> fun r -> r.SourceRangeStart + r.RangeLength

                    Some {
                        SourceRangeStart = nextRangeStart
                        DestinationRangeStart = nextRangeStart
                        RangeLength = Int64.MaxValue - nextRangeStart
                    }

                seq { before; yield! between; after } |> Seq.choose id

            { map with
                  Ranges =
                    explicitRanges
                    |> Seq.append implicitRanges
                    |> Seq.sortBy (fun r -> r.DestinationRangeStart)
                    |> Seq.toList
            }

        type CategoryRange = {
            Category: string
            RStart: int64
            RLength: int64
        }

        let solve text =

            let almanac = Parser.runAndUnwrap id pAlmanac text

            let initialCategoryRanges =
                almanac.SeedRanges
                |> List.map (fun sr -> { Category = "seed"; RStart = sr.SeedRangeStart; RLength = sr.SeedRangeLength })

            // Including implicit ranges simplifies calculation.
            let maps = almanac.Maps |> List.map includeImplicitRanges |> mapsInOrder

            (initialCategoryRanges, maps)
            ||> List.fold (fun categoryRanges map ->

                let sortedRanges = map.Ranges |> List.sortBy  (fun range -> range.SourceRangeStart)

                categoryRanges
                |> List.collect (fun cr ->

                    let cat, start = applyMap map (cr.Category, cr.RStart)

                    let filteredRanges =
                        sortedRanges
                        |> List.filter (fun r ->
                            cr.RStart < r.SourceRangeStart && r.SourceRangeStart < cr.RStart + cr.RLength)

                    let laterPartitions =
                        filteredRanges
                        |> List.choose (fun r ->
                            if cr.RStart < r.SourceRangeStart && r.SourceRangeStart < cr.RStart + cr.RLength then
                                Some {
                                    Category = map.Header.DestinationCategory
                                    RStart = r.DestinationRangeStart
                                    RLength = Math.Min(r.RangeLength, cr.RStart + cr.RLength - r.SourceRangeStart)
                                }
                            else
                                None)

                    let firstPartitionLength =
                        match filteredRanges |> List.tryHead with
                        | Some range -> range.SourceRangeStart - cr.RStart
                        | None -> cr.RLength

                    { Category = cat; RStart = start; RLength = firstPartitionLength } :: laterPartitions))
            |> List.map (fun r -> r.RStart)
            |> List.min

module Day6 =
    open FParsec

    let numberOfChargeTimesThatExceedRecordDistance (timeAllowed, recordDistance: int64) =
        // If charge time is c and time allowed is t, then the distance travelled is c(t-c). It beats the record
        // distance r if c(t-c) > r. Expressed another way: c^2 - tc + r < 0; or (c - t/2)^2 < (t^2)/4 - r.
        // From this expression it can be seen that for any value of c which satisfies this inequality, a
        // different value of c which is at least as close to t/2 as c will also satisfy the inequality. Thus,
        // if we find the lowest positive integer value of c for which the inequality holds, c' (for which
        // c' - t/2 will be negative), c' + 2 * (t/2 - c') = t - c' will be the largest positive integer value
        // of c for which the inequality holds. There are therefore (t - c') - c' + 1 = t - 2c' + 1
        // possibilities for c satisfying the inequality.
        Seq.init timeAllowed (fun i -> (int64 i) * ((int64 timeAllowed) - (int64 i)) - recordDistance)
        |> Seq.findIndex (fun d -> d > 0)
        |> fun c -> timeAllowed - 2 * c + 1

    module PartOne =
        let solve (lines: string array) =
            let times = lines.[0] |> Parser.runAndUnwrap id (pstring "Time:" >>. many (spaces1 >>. pint32))
            let distances = lines.[1] |> Parser.runAndUnwrap id (pstring "Distance:" >>. many (spaces1 >>. pint64))

            (times, distances)
            ||> List.zip
            |> List.map numberOfChargeTimesThatExceedRecordDistance
            |> List.reduce (*)

    module PartTwo =
        let solve (lines: string array) =
            let timeAllowed = lines.[0] |> Seq.filter Char.IsDigit |> Seq.toArray |> String |> Int32.Parse
            let recordDistance = lines.[1] |> Seq.filter Char.IsDigit |> Seq.toArray |> String |> Int64.Parse

            numberOfChargeTimesThatExceedRecordDistance (timeAllowed, recordDistance)

module Day7 =

    type Label =
        | Two
        | Three
        | Four
        | Five
        | Six
        | Seven
        | Eight
        | Nine
        | Ten
        | Jack
        | Queen
        | King
        | Ace

    type Type' =
        | HighCard
        | OnePair
        | TwoPair
        | ThreeOfAKind
        | FullHouse
        | FourOfAKind
        | FiveOfAKind

    let parse (line: string) =
        let parts = line.Split(' ')
        let hand =
            let labels = parts.[0]
            let parseLabel i =
                labels
                |> Seq.item i
                |> function
                    | '2' -> Two
                    | '3' -> Three
                    | '4' -> Four
                    | '5' -> Five
                    | '6' -> Six
                    | '7' -> Seven
                    | '8' -> Eight
                    | '9' -> Nine
                    | 'T' -> Ten
                    | 'J' -> Jack
                    | 'Q' -> Queen
                    | 'K' -> King
                    | 'A' -> Ace
                    | c -> failwith $"Invalid label char '%c{c}'"
            parseLabel 0, parseLabel 1, parseLabel 2, parseLabel 3, parseLabel 4
        let bid = parts.[1] |> Int32.Parse
        hand, bid

    let solve classify rank lines =
        lines
        |> Array.map parse
        |> Array.sortBy (fun (l1, l2, l3, l4, l5 as hand, _) ->
            classify hand, (rank l1, rank l2, rank l3, rank l4, rank l5))
        |> Array.mapi (fun i (_, bid) -> bid * (i + 1))
        |> Array.sum

    module PartOne =

        let classify (label1, label2, label3, label4, label5) =
            let labels = [ label1; label2; label3; label4; label5 ]
            let labelCounts = labels |> List.map (fun label -> labels |> List.filter ((=) label) |> List.length)
            let hasOfAKind i = labelCounts |> List.contains i
            let numberOfPairs = labelCounts |> List.filter ((=) 2) |> List.length |> fun i -> i / 2
            match hasOfAKind 5, hasOfAKind 4, hasOfAKind 3, numberOfPairs with
            | true, _, _, _ -> FiveOfAKind
            | false, true, _, _ -> FourOfAKind
            | false, false, true, 1 -> FullHouse
            | false, false, true, 0 -> ThreeOfAKind
            | false, false, false, 2 -> TwoPair
            | false, false, false, 1 -> OnePair
            | false, false, false, 0 -> HighCard
            | _, _, _, _ -> failwith $"Invalid labels %A{labels}"

        let solve = solve classify id

    module PartTwo =

        let rank =
            function
            | Jack -> 1
            | Two -> 2
            | Three -> 3
            | Four -> 4
            | Five -> 5
            | Six -> 6
            | Seven -> 7
            | Eight -> 8
            | Nine -> 9
            | Ten -> 10
            | Queen -> 11
            | King -> 12
            | Ace -> 13

        let classify (label1, label2, label3, label4, label5) =
            let labels = [ label1; label2; label3; label4; label5 ]
            let nonJackLabels = labels |> List.filter ((<>) Jack)
            let nonJackLabelCounts =
                nonJackLabels |> List.map (fun label -> nonJackLabels |> List.filter ((=) label) |> List.length)

            let hasOfAKind i = nonJackLabelCounts |> List.contains i
            let numberOfPairs = nonJackLabelCounts |> List.filter ((=) 2) |> List.length |> fun i -> i / 2
            let numberOfJacks = 5 - List.length nonJackLabels

            match hasOfAKind 5, hasOfAKind 4, hasOfAKind 3, numberOfPairs, numberOfJacks with
            | true, _, _, _, _ -> FiveOfAKind
            | false, true, _, _, 1 -> FiveOfAKind
            | false, true, _, _, 0 -> FourOfAKind
            | false, false, true, 1, _ -> FullHouse
            | false, false, true, 0, 2 -> FiveOfAKind
            | false, false, true, 0, 1 -> FourOfAKind
            | false, false, true, 0, 0 -> ThreeOfAKind
            | false, false, false, 2, 1 -> FullHouse
            | false, false, false, 2, 0 -> TwoPair
            | false, false, false, 1, 3 -> FiveOfAKind
            | false, false, false, 1, 2 -> FourOfAKind
            | false, false, false, 1, 1 -> ThreeOfAKind
            | false, false, false, 1, 0 -> OnePair
            | false, false, false, 0, 5 -> FiveOfAKind
            | false, false, false, 0, 4 -> FiveOfAKind
            | false, false, false, 0, 3 -> FourOfAKind
            | false, false, false, 0, 2 -> ThreeOfAKind
            | false, false, false, 0, 1 -> OnePair
            | false, false, false, 0, 0 -> HighCard
            | _, _, _, _, _ -> failwith $"Invalid labels %A{nonJackLabels}"

        let solve = solve classify rank

module Day8 =

    type Direction =
        | Left
        | Right

    type Node = {
        Label: char * char * char
        LeftLabel: char * char * char
        RightLabel: char * char * char
    }

    let parse lines =

        let directions =
            lines
            |> Array.item 0
            |> Seq.map (function
                | 'L' -> Left
                | 'R' -> Right
                | c -> failwith $"Invalid direction $c{c}")

        let nodes =
            lines
            |> Seq.skip 2
            |> Seq.map (fun line ->
                match line |> Seq.toList with
                | c1 :: c2 :: c3 :: ' ' :: '=' :: ' ' :: '(' :: l1 :: l2 :: l3 :: ',' :: ' ' :: r1 :: r2 :: r3 :: [ ')' ] ->
                    {
                        Label = c1, c2, c3
                        LeftLabel = l1, l2, l3
                        RightLabel = r1, r2, r3
                    }
                | _ -> failwith $"Invalid line: %s{line}")

        directions |> Seq.toArray, nodes |> Seq.toArray

    module PartOne =

        let solve lines =

            let directions, nodes = parse lines

            let steps =
                let lookup = nodes |> Seq.map (fun n -> n.Label, n) |> dict
                let direction i = Array.item (i % directions.Length) directions
                Array.unfold
                    (fun (i, node) ->
                        match node.Label, direction i with
                        | ('Z', 'Z', 'Z'), _ -> None
                        | _, Left -> let n = lookup.Item node.LeftLabel in Some (n, (i + 1, n))
                        | _, Right -> let n = lookup.Item node.RightLabel in Some (n, (i + 1, n)))
                    (0, lookup.Item ('A', 'A', 'A'))

            steps.Length

    module PartTwo =

        type PathSignature = {
            /// The number of steps before the cycle starts.
            PreCycleLength: int
            /// The indices of steps before the cycle that correspond to nodes whose label ends in Z.
            PreCycleZIndices: int array
            /// The number of steps in the cycle.
            CycleLength: int
            /// The indices, relative to the cycle start, of steps within the cycle that correspond to nodes whose label
            /// ends in Z.
            CycleZIndices: int array
        }

        let solve lines =

            let directions, nodes = parse lines
            let nodeLookup = nodes |> Seq.map (fun n -> n.Label, n) |> dict

            let startNodes =
                nodes
                |> Array.filter (fun n -> match n.Label with _, _, 'A' -> true | _ -> false)

            /// For a given node, returns the nodes visited by starting there and following directions in order. Returns
            /// the last such node separately.
            let journeyLookup =
                let journey startNode =
                    let nodesVisited =
                        directions
                        |> Array.scan
                            (fun n d ->
                                match d with
                                | Left -> nodeLookup.Item n.LeftLabel
                                | Right -> nodeLookup.Item n.RightLabel)
                            startNode
                    nodesVisited.[0 .. (nodesVisited.Length - 2)], nodesVisited |> Array.last

                nodes
                |> Array.map (fun n -> n, journey n)
                |> dict

            // Keep repeating a journey (following all directions through once) until we end at a node that was the
            // start of a previous journey. Returns the nodes at the start of those journeys, and the node that is
            // repeated first.
            let journeyStartsUntilFirstRepeat startNode =

                let starts =
                    ([| startNode |], Seq.initInfinite ignore)
                    ||> Seq.scan
                        (fun previousStarts ()  ->
                            if Seq.containsRepeats previousStarts then
                                previousStarts
                            else
                                let previous = previousStarts |> Array.last
                                let _, nextStart = journeyLookup.Item previous
                                Array.append previousStarts [| nextStart |])
                    |> Seq.skipWhile (not << Seq.containsRepeats)
                    |> Seq.head

                starts |> Array.removeAt (starts.Length - 1), starts |> Array.last

            /// Returns the steps that are before a cycle starts, and a cycle of steps starting immediately afterwards
            /// that repeats forever.
            let decomposeFrom startNode =

                let journeyStarts, cycleStart = journeyStartsUntilFirstRepeat startNode

                let cycleStartIndex = journeyStarts |> Array.findIndex ((=) cycleStart)
                let preCycle =
                    journeyStarts
                    |> Array.take cycleStartIndex
                    |> Array.collect (fun n -> journeyLookup.Item n |> fst)
                let cycle =
                    journeyStarts
                    |> Array.skip cycleStartIndex
                    |> Array.collect (fun n -> journeyLookup.Item n |> fst)

                preCycle, cycle

            let pathSignatures =
                let isZNode n = match n.Label with _, _, 'Z' -> true | _ -> false

                startNodes
                |> Array.map (fun startNode ->
                    let preCycle, cycle = decomposeFrom startNode
                    {
                        PreCycleLength = preCycle.Length
                        PreCycleZIndices =
                            preCycle
                            |> Array.mapi (fun i n -> i, isZNode n)
                            |> Array.filter snd
                            |> Array.map fst
                        CycleLength = cycle.Length
                        CycleZIndices =
                            cycle
                            |> Array.mapi (fun i n -> i, isZNode n)
                            |> Array.filter snd
                            |> Array.map fst
                    })

            // TODO: implement in generic way.
            // This is a hack that makes use of some observations I've made about the particular input I have. It's not
            // sufficiently generic to handle every possible input of this type.
            //
            // The observations that I've made use of are:
            // - There are no pre-cycle z-indices
            // - The pre-cycles are all the same length
            // - There is only one cycle z-index, which is pre-cycle length away from the end of the cycle.
            //
            // As a result, any step index that is a z-index of a path must be divisible by that path signature's cycle
            // length. So a step index that is a z-index of all paths is divisible by all cycle lengths. The first such
            // step index is the least common multiple of the cycle lengths.
            pathSignatures
            |> Array.map (fun i -> i.CycleLength |> Convert.ToUInt64)
            |> Array.reduce Math.lcm

module Day9 =
    open FParsec

    let pLine: Parser<int32 list, unit> = sepBy pint32 (pchar ' ')

    let solve extrapolate lines =

        let histories =
            lines
            |> Array.map (Parser.runAndUnwrap List.toArray pLine)

        let differences numbers =
            numbers
            |> Seq.pairwise
            |> Seq.map (fun (i, j) -> j - i)

        // This doesn't include the final sequence of zeroes that are in the puzzle description; it seems easier to
        // work without them. It does include the input as the first element.
        let successiveDifferences ns =
            let differences =
                Array.unfold
                    (fun numbers ->
                        let diffs = differences numbers |> Seq.toArray
                        if diffs |> Array.forall ((=) 0) then
                            None
                        else
                            Some (diffs, diffs)
                    )
                    ns

            Array.append [| ns |] differences

        histories
        |> Array.map successiveDifferences
        |> Array.map extrapolate
        |> Array.sum

    module PartOne =

        let extrapolate successiveDifferences =
            (successiveDifferences |> Array.map Array.last, 0)
            ||> Array.foldBack (fun last deeperLast -> last + deeperLast)

        let solve = solve extrapolate

    module PartTwo =

        let extrapolate successiveDifferences =
            (successiveDifferences |> Array.map Array.head, 0)
            ||> Array.foldBack (fun first deeperFirst -> first - deeperFirst)

        let solve = solve extrapolate

module Day10 =
    open System.Collections.Generic

    type Direction =
        | North
        | South
        | East
        | West

    module Direction =

        let opposite =
            function
            | North -> South
            | South -> North
            | East -> West
            | West -> East

    type Tile =
        | Pipe of Direction * Direction
        | Ground
        | StartingPosition

    let pTile =
        function
        | '|' -> Pipe (North, South)
        | '-' -> Pipe (East, West)
        | 'L' -> Pipe (North, East)
        | 'J' -> Pipe (North, West)
        | '7' -> Pipe (South, West)
        | 'F' -> Pipe (South, East)
        | '.' -> Ground
        | 'S' -> StartingPosition
        | c -> failwith $"Invalid tile char: '%c{c}"

    [<RequireQualifiedAccess>]
    module Tile =

        /// The directions that the pipe on the tile (if any) exits to.
        let exitDirections tile =
            match tile with
            | Pipe (a, b) -> [| a; b |]
            | Ground
            | StartingPosition -> [||]

        /// Whether the pipe on the tile (if any) has an exit in the given direction.
        let exits direction tile = tile |> exitDirections |> Array.contains direction

    /// Parses lines into an array of pairs, whose first elements are coordinates and second elements are the contents
    /// of the tile at those coordinates.
    let parse lines =
        lines
        |> Array.mapi (fun i line -> line |> Seq.mapi (fun j c -> (i, j), pTile c) |> Seq.toArray)
        |> Array.collect id

    /// Returns the coordinates of the starting tile, and a dictionary from coordinates to the tile contents. The value
    /// corresponding to the starting coordinates is the pipe that is calculated to be present there, not
    /// StartingPosition.
    let calculateStartCoordsAndTileLookup tiles =
        let startCoords = tiles |> Array.find (snd >> (=) StartingPosition) |> fst
        let lookup = dict tiles

        let startPipe =
            let exitDirections = [
                let exits direction coords =
                    coords |> lookup.TryGet |> Option.map (Tile.exits direction) |> Option.defaultValue false

                let i, j = startCoords

                if (i - 1, j) |> exits South then North
                if (i + 1, j) |> exits North then South
                if (i, j + 1) |> exits West then East
                if (i, j - 1) |> exits East then West
            ]

            Pipe (exitDirections.[0], exitDirections.[1])

        startCoords, dict (Array.append tiles [| startCoords, startPipe |])

    /// Returns a sequence of pairs whose first element represents a distance from the starting position in the main
    /// loop, and whose second element is the set of the coordinates which correspond to tiles at that distance.
    let calculateCoordsByDistanceSeq startCoords (tileLookup: IDictionary<int * int, Tile>) =

        let startDirections = tileLookup.Item startCoords |> Tile.exitDirections

        let distanceGoingIn startDirection =

            ((startCoords, startDirection), Seq.initInfinite ignore)
            ||> Seq.scan (fun ((i, j), inDirection) _ ->
                let outDirection =
                    tileLookup.Item (i, j)
                    |> Tile.exitDirections
                    |> Array.find ((<>) inDirection)

                let nextCoords =
                    match outDirection with
                    | North -> (i - 1, j)
                    | South -> (i + 1, j)
                    | East -> (i, j + 1)
                    | West -> (i, j - 1)

                (nextCoords, outDirection |> Direction.opposite))
            |> Seq.map fst

        (distanceGoingIn startDirections.[0], distanceGoingIn startDirections.[1])
        ||> Seq.zip
        |> Seq.indexed
        // The paths are guaranteed to hit the midpoint of the loop at the same time because the length of the main loop
        // is even: the number of steps North equals the number of steps South, and likewise for East and West.
        |> Seq.takeUntilFirstMatch (fun (distance, (cs1, cs2)) -> distance <> 0 && cs1 = cs2)
        |> Seq.map (fun (distance, (cs1, cs2)) -> distance, Set (seq { cs1; cs2 }))

    module PartOne =

        let solve lines =
            parse lines
            |> calculateStartCoordsAndTileLookup
            ||> calculateCoordsByDistanceSeq
            |> Seq.last
            |> fst

    module PartTwo =

        // Consider the vertices of the square tiles that make up the grid.
        // The tiles which are not inside the loop are precisely those which have a vertex that can be reached by a path
        // starting from a vertex on the edge of the grid that traverses along sides that aren't crossed by the main
        // loop (which is to say that the main loop does not go directly between the two tiles that share the side).
        // To find all such vertices this function starts with the vertices at the edge of grid and iteratively adds
        // adjacent vertices that can be reached without crossing the main loop, until no new vertices are added.
        let solve lines =

            let startTileCoords, tileLookup = parse lines |> calculateStartCoordsAndTileLookup

            let rowCount = tileLookup.Keys |> Seq.map fst |> Seq.max
            let columnCount = tileLookup.Keys |> Seq.map snd |> Seq.max

            let mainLoopTileCoords =
                (startTileCoords, tileLookup)
                ||> calculateCoordsByDistanceSeq
                |> Seq.map snd
                |> Set.unionMany

            let accessibleAdjacentVertices (i, j) = seq {
                // Vertex (i, j) is a vertex of the tiles (i-1, j-1), (i-1, j), (i, j-1), (i, j) that are present in the
                // grid (edge vertices won't have four such tiles around them).
                // The adjacent vertices are (i-1, j), (i, j-1), (i, j+1) and (i+1, j).
                //                            Vertex (i-1, j)
                //                                 |
                //                                 v
                //                    x------------x------------x
                //                    | (i-1, j-1) | (i-1, j)   |
                // Vertex (i, j-1) -> x------------x------------x <- Vertex (i, j+1)
                //                    | (i, j-1)   | (i, j)     |
                //                    x------------x------------x
                //                                 ^
                //                                 |
                //                           Vertex (i+1, j)
                let tileI'J' = (i-1, j-1) |> fun cs -> cs, tileLookup.TryGet cs
                let tileI'J = (i-1, j) |> fun cs -> cs, tileLookup.TryGet cs
                let tileIJ' = (i, j-1) |> fun cs -> cs, tileLookup.TryGet cs
                let tileIJ = (i, j) |> fun cs -> cs, tileLookup.TryGet cs

                let connectedByMainLoop (((cs1, t1), d1), ((cs2, t2), d2)) =
                    mainLoopTileCoords |> Set.contains cs1
                    && mainLoopTileCoords |> Set.contains cs2
                    &&
                        (t1, t2)
                        ||> Option.map2 (fun t1 t2 -> t1 |> Tile.exits d1 && t2 |> Tile.exits d2)
                        |> Option.defaultValue false

                // Vertex (i-1, j) can be reached if there is no East-West pipe between tiles (i-1, j-1) and (i-1, j).
                if i > 0 && not (connectedByMainLoop ((tileI'J', East), (tileI'J, West))) then (i-1, j)

                // Vertex (i, j-1) can be reached if there is no North-South pipe between tiles (i-1, j-1) and (i, j-1).
                if j > 0 && not (connectedByMainLoop ((tileI'J', South), (tileIJ', North))) then (i, j-1)

                // Vertex (i, j+1) can be reached if there is no North-South pipe between tiles (i-1, j) and (i, j).
                if j < columnCount && not (connectedByMainLoop ((tileI'J, South), (tileIJ, North))) then (i, j+1)

                // Vertex (i+1, j) can be reached if there is no East-West pipe between tiles (i, j-1) and (i, j).
                if i < rowCount && not (connectedByMainLoop ((tileIJ', East), (tileIJ, West))) then (i+1, j)
            }

            let edgeVertices =
                Seq.allPairs (seq { 0 .. rowCount + 1 }) (seq { 0 .. columnCount + 1 }) |> Set
                |> Set.filter (fun (i, j) -> i = 0 || i = rowCount + 1 || j = 0 || j = columnCount + 1)

            let unenclosedVertices =
                // Start with the vertices at the edge of grid.
                ((Set.empty, edgeVertices), Seq.initInfinite ignore)
                // Iteratively add all adjacent vertices that can be reached without crossing the main loop
                ||> Seq.scan
                    (fun (oldVertices, newVertices) _ ->
                        let verticesSoFar = Set.union oldVertices newVertices
                        let nextVertices =
                            newVertices
                            |> Seq.collect accessibleAdjacentVertices
                            |> Set
                            |> fun s -> Set.difference s verticesSoFar
                        verticesSoFar, nextVertices)
                // Until no new vertices are added.
                |> Seq.takeWhile (snd >> Set.isEmpty >> not)
                |> Seq.last
                ||> Set.union

            let enclosedTileCoords =
                let allTileCoords = Seq.allPairs (seq { 0 .. rowCount }) (seq { 0 .. columnCount }) |> Set

                unenclosedVertices
                |> Seq.map (fun (i, j) -> Set (seq { (i-1, j); (i-1, j-1); (i, j-1); (i, j) }))
                |> Set.unionMany
                |> fun unenclosedTileCoords -> Set.difference allTileCoords unenclosedTileCoords

            enclosedTileCoords |> Set.count

module Day11 =

    type Pixel =
        | EmptySpace
        | Galaxy

    module Pixel =

        let parse = function '.' -> EmptySpace | '#' -> Galaxy | c -> failwith $"Invalid pixel: %c{c}"

    let solve expansionFactor image =

        let universe = image |> Array2D.map Pixel.parse

        let rowNumbers = [| 0 .. (universe |> Array2D.length1) - 1 |]
        let colNumbers = [| 0 .. (universe |> Array2D.length2) - 1 |]

        let galaxyIndices =
            Seq.allPairs rowNumbers colNumbers
            |> Seq.filter (fun (i, j) -> Array2D.get universe i j = Galaxy)
            |> Seq.toArray

        let galaxyPairs =
            galaxyIndices
            |> Seq.mapi (fun i g1 -> galaxyIndices.[ (i+1) .. ] |> Array.map (fun g2 -> g1, g2))
            |> Seq.collect id

        let emptyRowNumbers =
            rowNumbers
            |> Array.filter (fun i -> colNumbers |> Array.forall (fun j -> Array2D.get universe i j = EmptySpace))
            |> Set

        let emptyColNumbers =
            colNumbers
            |> Array.filter (fun j -> rowNumbers |> Array.forall (fun i -> Array2D.get universe i j = EmptySpace))
            |> Set

        let shortestPathLength ((i1: int, j1: int), (i2, j2)) =

            let crossedEmptyRows =
                (if i2 > i1 then Set (seq { i1 .. i2 }) else Set (seq { i2 .. i1 }))
                |> Set.intersect emptyRowNumbers
                |> Set.count
                |> int64

            let crossedEmptyCols =
                (if j2 > j1 then Set (seq { j1 .. j2 }) else Set (seq { j2 .. j1 }))
                |> Set.intersect emptyColNumbers
                |> Set.count
                |> int64

            (Math.Abs(i2 - i1) |> int64)
            + (Math.Abs (j2 - j1) |> int64)
            + (expansionFactor - 1L) * (crossedEmptyRows + crossedEmptyCols)

        galaxyPairs |> Seq.sumBy shortestPathLength

    module PartOne =
        let solve = solve 2

    module PartTwo =
        let solve = solve 1_000_000L

module Day12 =
    open System.Collections.Generic

    type SpringStatus =
        | Operational
        | Damaged
        | Unknown

    module SpringStatus =

        let parse =
            function '.' -> Operational | '#' -> Damaged | '?' -> Unknown | c -> failwith $"Invalid status char: %c{c}"

    type RowInfo = {
        Row: SpringStatus array
        DamagedGroupSizes: int array
    }

    module RowInfo =

        // Need to use the structural equality comparer to ensure that different arrays with the same contents are
        // considered to be the same key.
        let private cache = Dictionary<SpringStatus array * int array, int64>(HashIdentity.Structural)

        let countPossibleArrangements info =

            let groupDoesNotFitAtStartOf (statuses: SpringStatus array) groupSize =

                let groupIsTooBig = groupSize > statuses.Length
                let groupWouldIntersectOperationalSpring = statuses.[ .. groupSize - 1 ] |> Array.contains Operational
                let followingSpringIsDamaged =
                    statuses
                    |> Array.tryItem groupSize
                    |> Option.map ((=) Damaged)
                    |> Option.defaultValue false

                groupIsTooBig
                || groupWouldIntersectOperationalSpring
                || followingSpringIsDamaged

            let rec inner =
                function
                | [||], [||] ->
                    1L
                | [||], _ ->
                    0L
                | statuses, [||] ->
                    if statuses |> Array.contains Damaged then 0L else 1L
                | statuses, groupSizes ->

                    cache.TryGet (statuses, groupSizes)
                    |> Option.defaultWith (fun _ ->

                        let numberOfPossibleArrangements =

                            let countOperational () = inner (Array.tail statuses, groupSizes)

                            let countDamaged () =
                                let groupSize = Array.head groupSizes
                                if groupSize |> groupDoesNotFitAtStartOf statuses then
                                    0L
                                else
                                    inner (statuses.[ groupSize + 1 .. ], Array.tail groupSizes)

                            match Array.head statuses with
                            | Operational -> countOperational ()
                            | Damaged -> countDamaged ()
                            | Unknown -> countOperational () + countDamaged ()

                        cache.Add((statuses, groupSizes), numberOfPossibleArrangements)

                        numberOfPossibleArrangements)

            inner (info.Row, info.DamagedGroupSizes)

    let solve parse lines =
        lines
        |> Array.map (parse >> RowInfo.countPossibleArrangements)
        |> Array.sum

    module PartOne =

        let parseRowInfo (line: string) =
            let parts = line.Split(' ')
            {
                Row = parts.[0] |> Seq.map SpringStatus.parse |> Seq.toArray
                DamagedGroupSizes = parts.[1].Split(',') |> Array.map int
            }

        let solve = solve parseRowInfo

    module PartTwo =

        let parseRowInfo line =
            line
            |> PartOne.parseRowInfo
            |> fun { Row = row; DamagedGroupSizes = sizes } ->
                {
                    Row =
                        [| row; [| Unknown |]; row; [| Unknown |]; row; [| Unknown |]; row; [| Unknown |]; row |]
                        |> Array.collect id
                    DamagedGroupSizes =
                        sizes
                        |> Array.replicate 5
                        |> Array.collect id
                }

        let solve = solve parseRowInfo

module Day13 =

    module PartOne =

        let hasHorizontalLineOfSymmetryBeforeRow n pattern =

            let height = pattern |> Array2D.length1
            let numRowPairsToTest = Math.Min(height - 1 - n, n - 1)

            seq { 0 .. numRowPairsToTest }
            |> Seq.forall (fun i -> Array2D.row (n - 1 - i) pattern = Array2D.row (n + i) pattern)

        let hasVerticalLineOfSymmetryBeforeColumn n pattern =

            let width = pattern |> Array2D.length2
            let numColumnPairsToTest = Math.Min(width - 1 - n, n - 1)

            seq { 0 .. numColumnPairsToTest }
            |> Seq.forall (fun j -> Array2D.column (n - 1 - j) pattern = Array2D.column (n + j) pattern)

        let solve (text: string) =
            text.Split("\n\n")
            |> Array.map (fun patternStr ->
                patternStr.Split('\n') |> Array.filter (not << String.IsNullOrWhiteSpace) |> array2D)
            |> Array.map (fun pattern ->
                // Start at 1 because before row 0 would pass the test but have no reflected rows.
                seq { 1 .. Array2D.length1 pattern - 1 }
                |> Seq.tryFind (fun n -> pattern |> hasHorizontalLineOfSymmetryBeforeRow n)
                |> Option.map (fun n -> n * 100)
                |> Option.defaultWith (fun _ ->
                    seq { 1 .. Array2D.length2 pattern - 1 }
                    |> Seq.find (fun n -> pattern |> hasVerticalLineOfSymmetryBeforeColumn n)))
            |> Array.sum

    module PartTwo =

        let private hasExactlyOneFalse seq =
            seq
            // Generate running false total.
            |> Seq.scan (fun running testResult -> if testResult then running else running + 1) 0
            // Stop if running total reaches 2 (to avoid unnecessary work).
            |> Seq.takeUntilFirstMatch ((=) 2)
            |> Seq.last
            // It is a candidate if there is only one mismatch.
            |> (=) 1

        let hasSmudgedHorizontalLineOfSymmetryBeforeRow n pattern =

            let height, width = pattern |> Array2D.length1, pattern |> Array2D.length2
            let numRowPairsToTest = Math.Min(height - 1 - n, n - 1)

            seq { 0 .. numRowPairsToTest }
            // Generate sequence of results from testing whether corresponding elements across line being tested for
            // symmetry are equal.
            |> Seq.collect (fun i ->
                seq { 0 .. width - 1 }
                |> Seq.map (fun j -> Array2D.get pattern (n - 1 - i) j = Array2D.get pattern (n + i) j))
            |> hasExactlyOneFalse

        let hasSmudgedVerticalLineOfSymmetryBeforeColumn n pattern =

            let height, width = pattern |> Array2D.length1, pattern |> Array2D.length2
            let numColumnPairsToTest = Math.Min(width - 1 - n, n - 1)

            seq { 0 .. numColumnPairsToTest }
            // Generate sequence of results from testing whether corresponding elements across line being tested for
            // symmetry are equal.
            |> Seq.collect (fun j ->
                seq { 0 .. height - 1 }
                |> Seq.map (fun i -> Array2D.get pattern i (n - 1 - j) = Array2D.get pattern i (n + j)))
            |> hasExactlyOneFalse

        let solve (text: string) =
            text.Split("\n\n")
            |> Array.map (fun patternStr ->
                patternStr.Split('\n') |> Array.filter (not << String.IsNullOrWhiteSpace) |> array2D)
            |> Array.map (fun pattern ->
                // Start at 1 because before row 0 would pass the test but have no reflected rows.
                seq { 1 .. Array2D.length1 pattern - 1 }
                |> Seq.tryFind (fun n -> pattern |> hasSmudgedHorizontalLineOfSymmetryBeforeRow n)
                |> Option.map (fun n -> n * 100)
                |> Option.defaultWith (fun _ ->
                    seq { 1 .. Array2D.length2 pattern - 1 }
                    |> Seq.find (fun n -> pattern |> hasSmudgedVerticalLineOfSymmetryBeforeColumn n)))
            |> Array.sum

module Day14 =

    /// The new platform arrangement after tilting towards the start of all of the lines (so if lines are the
    /// columns, this tilts towards the top row).
    let tilt lineLength lines =

        lines
        |> Seq.map (fun col ->

            // Produce a sequence of pairs of the indices (counted from the northernmost row) where the boulders
            // stop and the number of boulders lined up from that point.
            let pairs =
                ([ (0, 0) ], col |> Seq.indexed)
                ||> Seq.fold (fun list (i, c) ->
                    match c, list with
                    | '.', (a, n) :: tail -> (a, n) :: tail
                    | 'O', (a, n) :: tail -> (a, n + 1) :: tail
                    | '#', list -> (i + 1, 0) :: list
                    | _, [] -> failwith "Bug: invalid state"
                    | c, _ -> failwith $"Column %A{col} has invalid character '%c{c}' in position %i{i}")
                |> Seq.filter (snd >> ((<>) 0))

            let roundIndices =
                (Seq.empty, pairs |> Seq.rev)
                ||> Seq.fold (fun state (i, n) -> seq {
                    yield! state
                    yield! seq { i .. i + n - 1 }
                })
                |> Set

            let cubeIndices = col |> Seq.indexed |> Seq.filter (snd >> ((=) '#')) |> Seq.map fst |> Set

            seq {
                for i in 0 .. lineLength - 1 do
                    if roundIndices |> Set.contains i then 'O'
                    elif cubeIndices |> Set.contains i then '#'
                    else '.'
            })

    let tiltNorth height rows = rows |> Seq.transpose |> tilt height |> Seq.transpose
    let tiltWest width rows = rows |> tilt width
    let tiltSouth height rows = rows |> Seq.transpose |> Seq.map Seq.rev |> tilt height |> Seq.map Seq.rev |> Seq.transpose
    let tiltEast width rows = rows |> Seq.map Seq.rev |> tilt width |> Seq.map Seq.rev

    let totalLoad rows =
        rows
        |> Seq.transpose
        |> Seq.collect (Seq.rev >> Seq.mapi (fun i x -> ((i + 1), x))  >> Seq.filter (snd >> ((=) 'O')) >> Seq.map fst)
        |> Seq.sum

    module PartOne =

        let solve lines =
            lines
            |> tiltNorth (Array.length lines)
            |> totalLoad

    module PartTwo =

        let spin height width rows =

            rows
            |> tiltNorth height
            |> tiltWest width
            |> tiltSouth height
            |> tiltEast width
            // Evaluate the sequences to avoid multiple evaluations when checking equality of elements.
            |> Seq.map Seq.toArray
            |> Seq.toArray

        let solve lines =

            let rows = lines |> Array.map Seq.toArray

            let elementCalculator =
                // TODO: explain why this falls into a cycle before one billion elements. It feels right, but I don't
                // have proof that it would for every possible puzzle input.
                Seq.repeatingSequenceElementCalculator
                    (spin (rows |> Array.length) (rows |> Array.head |> Array.length))
                    rows

            elementCalculator 1_000_000_000
            |> totalLoad

module Day15 =

    let steps initializationSequence = initializationSequence |> String.filter ((<>) '\n') |> fun s -> s.Split(',')

    let hash (input: char seq) = (0, input) ||> Seq.fold (fun currentValue c -> ((currentValue + (int c)) * 17 % 256))

    module PartOne =

        let solve initializationSequence = initializationSequence |> steps |> Array.map hash |> Array.sum

    module PartTwo =

        let solve initializationSequence =

            let boxes = Collections.Generic.Dictionary()
            for i in 0 .. 255 do
                boxes[i] <- [||]

            initializationSequence
            |> steps
            |> Seq.iter (fun step ->

                let span = step.AsSpan()

                let label = step |> Seq.take (span.LastIndexOfAny('-', '=')) |> Seq.toArray |> String
                let boxNumber = label |> hash
                let operationIndex = span.LastIndexOfAny('-', '=')

                match span.Item operationIndex with
                | '=' ->

                    let prevContents = boxes.Item boxNumber

                    let newContents =

                        let focalLength = span.Item (operationIndex + 1) |> string |> Int32.Parse

                        prevContents
                        |> Array.tryFindIndex (fst >> ((=) label))
                        |> Option.map (fun i -> prevContents |> Array.updateAt i (label, focalLength))
                        |> Option.defaultWith (fun _ -> Array.append prevContents [| (label, focalLength) |])

                    boxes[boxNumber] <- newContents

                | '-' ->
                    boxes.Item boxNumber
                    |> Array.filter (fst >> ((<>) label))
                    |> fun newContents -> boxes[boxNumber] <- newContents
                | c ->
                    failwith $"Invalid operation character %c{c}")

            (0, seq { 0 .. 255 })
            ||> Seq.fold (fun sum boxNumber ->
                let boxSum =
                    ((1, 0), boxes.[boxNumber])
                    ||> Array.fold (fun (slotNumber, boxSum) (_label, focalLength) ->
                        slotNumber + 1, boxSum + (boxNumber + 1) * slotNumber * focalLength)
                    |> snd
                sum + boxSum)

module Day16 =

    type Tile =
        | EmptySpace
        | FMirror
        | BMirror
        | HSplitter
        | VSplitter

    type Direction =
        | Upward
        | Downward
        | Leftward
        | Rightward

    type BeamSegment = {
        Row: int
        Col: int
        Direction: Direction
    }

    let parse lines =
        lines
        |> array2D
        |> Array2D.map (
            function
            | '.' -> EmptySpace
            | '/' -> FMirror
            | '\\' -> BMirror
            | '-' -> HSplitter
            | '|' -> VSplitter
            | c -> failwith $"Invalid tile char '%c{c}'")

    /// Returns a function that, given a segment, returns the segments that come next.
    let nextSegments layout =

        let height, width = layout |> Array2D.length1, layout |> Array2D.length2

        // Return anonymous function to avoid recalculation of height and width.
        fun segment ->

            let up =
                if segment.Row > 0 then
                    Some { segment with Row = segment.Row - 1; Direction = Upward }
                else
                    None
            let down =
                if segment.Row < height - 1 then
                    Some { segment with Row = segment.Row + 1; Direction = Downward }
                else
                    None
            let left =
                if segment.Col > 0 then
                    Some { segment with Col = segment.Col - 1; Direction = Leftward }
                else
                    None
            let right =
                if segment.Col < width - 1 then
                    Some { segment with Col = segment.Col + 1; Direction = Rightward }
                else
                    None

            match layout.[ segment.Row, segment.Col ], segment.Direction with
            | (EmptySpace | VSplitter), Upward -> [| up |]
            | (EmptySpace | VSplitter), Downward -> [| down |]
            | (EmptySpace | HSplitter), Leftward -> [| left |]
            | (EmptySpace | HSplitter), Rightward -> [| right |]
            | VSplitter, (Leftward | Rightward) -> [| up; down |]
            | HSplitter, (Upward | Downward) -> [| left; right |]
            | FMirror, Upward -> [| right |]
            | FMirror, Downward -> [| left |]
            | FMirror, Leftward -> [| down |]
            | FMirror, Rightward -> [| up |]
            | BMirror, Upward -> [| left |]
            | BMirror, Downward -> [| right |]
            | BMirror, Leftward -> [| up |]
            | BMirror, Rightward -> [| down |]
            |> Array.choose id

    /// A sequence whose nth element is an array of BeamSegments that the beam is in n steps after the startSegment.
    let steps layout startSegment =
        [| startSegment |]
        |> Seq.unfold (Array.collect (nextSegments layout) >> function [||] -> None | next -> Some (next, next))
        |> Seq.append (seq { [| startSegment |] })

    /// Returns a function that, given a BeamSegment, returns the path starting from it until it splits or leaves the
    /// grid. The path before the split or exit is returned as the first element of the pair; the second element
    /// contains the segments that come after the split or exit.
    let pathUntilSplitOrExit layout =

        fun startSegment ->

            startSegment
            |> steps layout
            |> Seq.takeUntilFirstMatch (Array.length >> ((<>) 1))
            |> Seq.toArray
            |> fun until ->
                let beforeSplitOrExit = until |> Array.take (until.Length - 1) |> Array.map Array.head
                let afterSplitOrExit = until |> Array.last
                beforeSplitOrExit, afterSplitOrExit

        |> memoize

    let countEnergizedTiles layout startSegment =

        let pathUntilSplitOrExit = pathUntilSplitOrExit layout

        let startSegments =
            (Set.empty, Set [ startSegment ])
            |> Seq.unfold
                (fun (oldStartSegments, startSegments) ->

                    let oldSegments = Set.union oldStartSegments startSegments

                    let newStartSegments =
                        startSegments
                        |> Set.map (pathUntilSplitOrExit >> snd >> set)
                        |> Set.unionMany
                        |> fun s -> Set.difference s oldSegments

                    if newStartSegments |> Set.isEmpty then
                        None
                    else
                        Some ((oldSegments |> Set.union newStartSegments, (oldSegments, newStartSegments))))
            |> Seq.last

        startSegments
        |> Set.map (fun x -> x |> pathUntilSplitOrExit |> fst |> Array.append [| x |] |> set)
        |> Set.unionMany
        |> Set.map (fun seg -> seg.Row, seg.Col)
        |> Set.count

    module PartOne =

        let solve lines = countEnergizedTiles (parse lines) { Row = 0; Col = 0; Direction = Rightward }

    module PartTwo =

        // TODO: speed up - takes about 15 seconds.
        let solve lines =

            let layout = parse lines

            seq {

                let height, width = layout |> Array2D.length1, layout |> Array2D.length2

                for i in 0 .. height - 1 do
                    { Row = i; Col = 0; Direction = Rightward }
                    { Row = i; Col = width - 1; Direction = Leftward }

                for j in 0 .. width - 1 do
                    { Row = 0; Col = j; Direction = Downward }
                    { Row = height - 1; Col = j; Direction = Upward }

            }
            |> Seq.map (countEnergizedTiles layout)
            |> Seq.max

module Day17 =
    open System.Collections.Generic

    type Direction =
        | Up
        | Down
        | Left
        | Right

    module Direction =

        let orthogonal =
            function
            | Up | Down -> [| Left; Right |]
            | Left | Right -> [| Up; Down |]

    type Node = {
        Location: int * int
        // Optional because there is no approach for the start node.
        /// int represents number of steps in that direction leading up to the location.
        Approach: (Direction * int) option
    }

    let locationInDirection numRows numCols (row, col) direction =
        match direction, row, col with
        | Up, 0, _ -> None
        | Up, row, col -> Some (row - 1, col)
        | Down, row, _ when row = numRows - 1 -> None
        | Down, row, col -> Some (row + 1, col)
        | Left, _, 0 -> None
        | Left, row, col -> Some (row, col - 1)
        | Right, _, col when col = numCols - 1 -> None
        | Right, row, col -> Some (row, col + 1)

    let nextNodes numRows numCols canContinueInSameDirection canMakeQuarterTurn node =

        match node.Approach, node.Location with
        | None, (0, 0) ->
            seq {
                { Location = (0, 1); Approach = Some (Right, 1) }
                { Location = (1, 0); Approach = Some (Down, 1) }
            }

        | None, loc ->
            failwith $"Non-start node at location %A{loc} has no approach"

        | Some (entryDir, stepCount), loc ->
            seq {

                if canMakeQuarterTurn stepCount then
                    yield!
                        entryDir
                        |> Direction.orthogonal
                        |> Seq.map (fun exitDir ->
                            locationInDirection numRows numCols loc exitDir
                            |> Option.map (fun newLoc -> { Location = newLoc; Approach = Some (exitDir, 1) }))

                if canContinueInSameDirection stepCount then
                    locationInDirection numRows numCols loc entryDir
                    |> Option.map (fun newLoc ->
                        { Location = newLoc; Approach = Some (entryDir, stepCount + 1) })

            }
            |> Seq.choose id

    // Uses Dijkstra's algorithm.
    let solve nextNodes isEndNode (map: int array2d) =

        let startNode = { Location = (0, 0); Approach = None }

        let nodesByHeatLoss = PriorityQueue<Node, int>()
        nodesByHeatLoss.Enqueue(startNode, 0)
        let minHeatLossTo = Dictionary<Node, int> [ KeyValuePair (startNode, 0) ]
        let mutable minHeatLossToEndLocation : int option = None

        while minHeatLossToEndLocation.IsNone && nodesByHeatLoss.Count > 0 do

            match nodesByHeatLoss.Dequeue() with
            | current when isEndNode current ->
                minHeatLossToEndLocation <- Some minHeatLossTo.[current]

            | current ->

                current
                |> nextNodes
                |> Seq.iter (fun ({ Location = row, col } as next) ->

                    let newHeatLoss = minHeatLossTo.[current] + map.[ row, col ]

                    let nodeAlreadyVisitedWithLessHeatLoss =
                        next
                        |> minHeatLossTo.TryGet
                        |> Option.map (fun minHeatLoss -> minHeatLoss <= newHeatLoss)
                        |> Option.defaultValue false

                    if nodeAlreadyVisitedWithLessHeatLoss then
                        ()
                    else
                        minHeatLossTo.[next] <- newHeatLoss
                        nodesByHeatLoss.Enqueue(next, newHeatLoss))

        minHeatLossToEndLocation

    module PartOne =

        let solve lines =
            lines
            |> array2D
            |> Array2D.map (Char.ToString >> Int32.Parse)
            |> fun map ->
                let numRows, numCols = map |> Array2D.length1, map |> Array2D.length2
                let nextNodes = nextNodes numRows numCols (fun stepCount -> stepCount < 3) (fun _ -> true)
                let isEndNode =
                    fun { Location = row, col } ->
                        row = numRows - 1 && col = numCols - 1

                solve nextNodes isEndNode map

    module PartTwo =

        let solve lines =
            lines
            |> array2D
            |> Array2D.map (Char.ToString >> Int32.Parse)
            |> fun map ->

                let numRows, numCols = map |> Array2D.length1, map |> Array2D.length2

                let nextNodes =
                    nextNodes numRows numCols (fun stepCount -> stepCount < 10) (fun stepCount -> stepCount > 3)

                let isEndNode ({ Location = row, col } as node) =
                    let isEndLocation = row = numRows - 1 && col = numCols - 1
                    let canStop =
                        node.Approach
                        |> Option.map (fun (_, stepCount) -> stepCount >= 4)
                        |> Option.defaultValue false

                    isEndLocation && canStop

                solve nextNodes isEndNode map

module Day18 =

    type Direction =
        | Up
        | Down
        | Left
        | Right

    type PlanStep = {
        Direction: Direction
        Metres: int
    }

    module PartOne =

        let calculateEdgeCoords plan =
            ([| (0, 0) |], plan)
            ||> Array.fold (fun edgeCoords step ->

                let row, col = edgeCoords |> Array.last

                let newCoords =
                    match step.Direction with
                    | Up -> [| 1 .. step.Metres |] |> Array.map (fun i -> (row - i, col))
                    | Down -> [| 1 .. step.Metres |] |> Array.map (fun i -> (row + i, col))
                    | Left -> [| 1 .. step.Metres |] |> Array.map (fun i -> (row, col - i))
                    | Right -> [| 1 .. step.Metres |] |> Array.map (fun i -> (row, col + i))

                Array.append edgeCoords newCoords)

        // Uses breadth-first search to determine squares outside the trench.
        let calculateExteriorSquares
            trenchEdgeCoords
            (boundingRectangleTop, boundingRectangleBottom, boundingRectangleLeft, boundingRectangleRight)
            =

            let exteriorSquaresOnRectangleEdge =
                [|

                    for col in boundingRectangleLeft .. boundingRectangleRight do
                        boundingRectangleTop, col
                        boundingRectangleBottom, col

                    for row in boundingRectangleTop .. boundingRectangleBottom do
                        row, boundingRectangleLeft
                        row, boundingRectangleRight

                |]
                |> Array.except trenchEdgeCoords

            let adjacentSquares (row, col) = [|
                if row > boundingRectangleTop then row - 1, col
                if row < boundingRectangleBottom then row + 1, col
                if col > boundingRectangleLeft then row, col - 1
                if col < boundingRectangleRight then row, col + 1
            |]

            ([||], exteriorSquaresOnRectangleEdge)
            |> Array.unfold (fun (earlierExteriorSquares, previousExteriorSquares) ->

                let exteriorSquaresSoFar = Array.append previousExteriorSquares earlierExteriorSquares

                let nextExteriorSquares =
                    previousExteriorSquares
                    |> Array.collect adjacentSquares
                    |> Array.except exteriorSquaresSoFar
                    |> Array.except trenchEdgeCoords

                match nextExteriorSquares with
                | [||] -> None
                | ss -> Some (Array.append ss exteriorSquaresSoFar, (exteriorSquaresSoFar, ss)))

            |> Array.last

        let solveFromPlan plan =

            let trenchEdgeCoords = plan |> calculateEdgeCoords

            let boundingRectangleTop, boundingRectangleBottom, boundingRectangleLeft, boundingRectangleRight =
                let rows = trenchEdgeCoords |> Seq.map fst
                let cols = trenchEdgeCoords |> Seq.map snd
                rows |> Seq.min, rows |> Seq.max, cols |> Seq.min, cols |> Seq.max

            let exteriorSquares =
                calculateExteriorSquares
                    trenchEdgeCoords
                    (boundingRectangleTop, boundingRectangleBottom, boundingRectangleLeft, boundingRectangleRight)

            // Return bounding rectangle area less number of exterior squares.
            ((boundingRectangleRight - boundingRectangleLeft + 1) |> int64)
            * ((boundingRectangleBottom - boundingRectangleTop + 1) |> int64)
            - exteriorSquares.LongLength

        let parseLines (lines: string array) =
            lines
            |> Array.map (fun line ->
                let parts = line.Split(' ')
                {
                    Direction =
                        match parts.[0].[0] with
                        | 'U' -> Up
                        | 'D' -> Down
                        | 'L' -> Left
                        | 'R' -> Right
                        | c -> failwith $"Invalid direction char %c{c}"
                    Metres = parts.[1] |> Int32.Parse
                })

        let solve lines = lines |> parseLines |> solveFromPlan

    module PartTwo =

        let parseLines (lines: string array) =
            lines
            |> Array.map (fun line ->
                let parts = line.Split(' ')
                let hexCode = parts.[2].Substring(2, 5)
                let dirCode = parts.[2].[7]
                {
                    Direction =
                        match dirCode with
                        | '0' -> Right
                        | '1' -> Down
                        | '2' -> Left
                        | '3' -> Up
                        | c -> failwith $"Invalid direction code %c{c}"
                    Metres = Convert.ToInt32(hexCode, 16)
                })

        type HorizontalEdge = {
            Row: int
            Left: int
            Right: int
        }

        type VerticalEdge = {
            Col: int
            Top: int
            Bottom: int
        }

        let calculateEdges steps =

            let _, horizontalEdges, verticalEdges =
                (((0, 0), [], []), steps)
                ||> Array.fold (fun ((startRow, startCol), hs, vs) ->
                    function
                    | { Direction = Up; Metres = m } ->
                        { Col = startCol; Top = startRow - m; Bottom = startRow }
                        |> fun newV -> (startRow - m, startCol), hs, newV :: vs
                    | { Direction = Down; Metres = m } ->
                        { Col = startCol; Top = startRow; Bottom = startRow + m }
                        |> fun newV -> (startRow + m, startCol), hs, newV :: vs
                    | { Direction = Left; Metres = m } ->
                        { Row = startRow; Left = startCol - m; Right = startCol }
                        |> fun newH -> (startRow, startCol - m), newH :: hs, vs
                    | { Direction = Right; Metres = m } ->
                        { Row = startRow; Left = startCol; Right = startCol + m }
                        |> fun newH -> (startRow, startCol + m), newH :: hs, vs)

            horizontalEdges, verticalEdges

        let internalSquaresInRow verticalEdges row =

            let rec inner interiorStart squaresSoFar vEdges =

                match interiorStart, vEdges with
                // Outside shape and no more edges.
                | None, [] ->
                    squaresSoFar

                // Outside shape before vl; horizontal edge between vl and vr; inside shape after vr.
                | None, vl :: vr :: vs when vl.Bottom = row && vr.Top = row || vl.Top = row && vr.Bottom = row ->
                    inner (Some vl.Col) squaresSoFar vs

                // Outside shape before vl; horizontal edge between vl and vr; outside shape after vr.
                | None, vl :: vr :: vs when vl.Bottom = row && vr.Bottom = row || vl.Top = row && vr.Top = row ->
                    inner None (squaresSoFar + vr.Col - vl.Col + 1) vs

                // Outside shape before v; inside after v.
                | None, v :: vs ->
                    inner (Some v.Col) squaresSoFar vs

                // Inside shape and no more edges; invalid.
                | Some c, [] ->
                    failwith $"Interior opened at (%i{row}, %i{c}) and never closed."

                // Inside shape before vl; horizontal edge between vl and vr; outside shape after vr.
                | Some c, vl :: vr :: vs when vl.Bottom = row && vr.Top = row || vl.Top = row && vr.Bottom = row ->
                    inner None (squaresSoFar + vr.Col - c + 1) vs

                // Inside shape before vl; horizontal edge between vl and vr; inside shape after vr.
                | Some c, vl :: vr :: vs when vl.Bottom = row && vr.Bottom = row || vl.Top = row && vr.Top = row ->
                    inner (Some c) squaresSoFar vs

                // Inside shape before v; outside after v.
                | Some c, v :: vs ->
                    inner None (squaresSoFar + v.Col - c + 1) vs

            verticalEdges
            |> List.filter (fun v -> v.Top <= row && v.Bottom >= row)
            |> List.sortBy _.Col
            |> inner None 0
            |> int64

        /// Calculates the total area of the bands between the rows with horizontal edges.
        let areaInRowsBetweenHorizontalEdges rowsWithHorizontalEdges verticalEdgesLeftToRight=
            rowsWithHorizontalEdges
            |> Seq.sort
            // Split the shape into bands between horizontal edges (not including those edges).
            |> Seq.pairwise
            // Map to the total area of the parts of the shape inside the band.
            |> Seq.map (fun (bandTopRow, bandBottomRow) ->
                verticalEdgesLeftToRight
                // Only consider the vertical edges that split the band.
                |> List.filter (fun v -> v.Top <= bandTopRow && v.Bottom >= bandBottomRow)
                // Consider the rectangles bounded by such edges.
                |> List.pairwise
                // The rectangles alternate between inside and outside the shape.
                |> List.mapi (fun i ({ Col = l }, { Col = r }) -> (if i % 2 = 0 then r - l + 1 else 0) |> int64)
                // This sum is the total width of the band's rectangles inside the shape.
                |> List.sum
                // Multiplying by the band height gives the total area of the parts of the shape inside the band.
                |> (*) ((bandBottomRow - bandTopRow - 1) |> int64))
            |> Seq.sum

        let solve lines =

            let rowsWithHorizontalEdges, verticalEdgesLeftToRight =
                let horizontalEdges, verticalEdges = lines |> parseLines |> calculateEdges
                horizontalEdges |> Seq.map _.Row |> Seq.distinct |> Seq.toArray, verticalEdges |> List.sortBy _.Col

            let areaInRowsWithHorizontalEdges =
                rowsWithHorizontalEdges |> Array.sumBy (internalSquaresInRow verticalEdgesLeftToRight)

            let areaInRowsBetweenHorizontalEdges =
                areaInRowsBetweenHorizontalEdges rowsWithHorizontalEdges verticalEdgesLeftToRight

            areaInRowsWithHorizontalEdges + areaInRowsBetweenHorizontalEdges

module Day19 =

    type Condition =
        | LessThan of int
        | GreaterThan of int

    type ConditionalRule = {
        Category: char
        Condition: Condition
        Destination: string
    }

    type Rules =
        | Unconditional of string
        | Conditional of ConditionalRule * Rules

    type Workflow = {
        Name: string
        Rules: Rules
    }

    let parseWorkflow (line: string) =

        let openBraceIx = line |> Seq.findIndex ((=) '{')

        {
            Name = line.Substring(0, openBraceIx)
            Rules =
                let strings =
                    line
                        .Substring(openBraceIx + 1, line.Length - openBraceIx - 2)
                        .Split(',')
                (strings.[ .. strings.Length - 2], strings |> Array.last |> Unconditional)
                ||> Array.foldBack (fun s rule->
                        let colonIx = s |> Seq.findIndex ((=) ':')
                        let conditionType =
                            match s.Chars 1 with
                            | '<' -> LessThan
                            | '>' -> GreaterThan
                            | _ -> failwith "Invalid rule"
                        {
                            Category = s.Chars 0
                            Condition = s.Substring(2, colonIx - 2) |> int |> conditionType
                            Destination = s.Substring(colonIx + 1, s.Length - colonIx - 1)
                        }
                        |> fun conditional -> Conditional (conditional, rule))
        }

    type Rating = {
        X: int
        M: int
        A: int
        S: int
    }

    let parseRating (line: string) =
        line.Substring(1, line.Length - 2)
        |> (fun s ->
            let parts = s.Split(',')
            let x, m, a, s = parts.[0], parts.[1], parts.[2], parts.[3]
            {
                X = x.Substring(2, x.Length - 2) |> int
                M = m.Substring(2, m.Length - 2) |> int
                A = a.Substring(2, a.Length - 2) |> int
                S = s.Substring(2, s.Length - 2) |> int
            })

    let parse (text: string) =
        let tokens = text.Split("\n\n")
        let workflows = tokens.[0].Split('\n') |> Array.map parseWorkflow
        let ratings = tokens.[1].Split('\n') |> Array.filter (not << String.IsNullOrWhiteSpace) |> Array.map parseRating

        workflows, ratings
    module PartOne =

        let rec applyRule ({ X = x; M = m; A = a; S = s } as rating) =
            function
            | Unconditional d ->
                d
            | Conditional ({ Category = 'x'; Condition = LessThan i; Destination = d }, next) ->
                if x < i then d else applyRule rating next
            | Conditional ({ Category = 'x'; Condition = GreaterThan i; Destination = d }, next) ->
                if x > i then d else applyRule rating next
            | Conditional ({ Category = 'm'; Condition = LessThan i; Destination = d }, next) ->
                if m < i then d else applyRule rating next
            | Conditional ({ Category = 'm'; Condition = GreaterThan i; Destination = d }, next) ->
                if m > i then d else applyRule rating next
            | Conditional ({ Category = 'a'; Condition = LessThan i; Destination = d }, next) ->
                if a < i then d else applyRule rating next
            | Conditional ({ Category = 'a'; Condition = GreaterThan i; Destination = d }, next) ->
                if a > i then d else applyRule rating next
            | Conditional ({ Category = 's'; Condition = LessThan i; Destination = d }, next) ->
                if s < i then d else applyRule rating next
            | Conditional ({ Category = 's'; Condition = GreaterThan i; Destination = d }, next) ->
                if s > i then d else applyRule rating next
            | Conditional ({ Category = c }, _) ->
                failwith $"Invalid rating category: %c{c}"

        let ratingSum { X = x; M = m; A = a; S = s } = x + m + a + s

        let isAccepted workflows =

            let rulesLookup = workflows |> Array.map (fun w -> w.Name, w.Rules) |> Map |> Collections.Generic.Dictionary

            let rec inner workflowName rating =

                rulesLookup.Item workflowName
                |> applyRule rating
                |> function
                    | "A" -> true
                    | "R" -> false
                    | d -> inner d rating

            inner "in"

        let solve text =

            let workflows, ratings = parse text

            ratings
            |> Array.filter (isAccepted workflows)
            |> Array.sumBy ratingSum

    module PartTwo =

        type RatingRange = {
            XMin: int
            XMax: int
            MMin: int
            MMax: int
            AMin: int
            AMax: int
            SMin: int
            SMax: int
        }

        module RatingRange =

            let min category range =
                match category with
                | 'x' -> range.XMin
                | 'm' -> range.MMin
                | 'a' -> range.AMin
                | 's' -> range.SMin
                | c -> failwith $"Invalid category %c{c}"

            let max category range =
                match category with
                | 'x' -> range.XMax
                | 'm' -> range.MMax
                | 'a' -> range.AMax
                | 's' -> range.SMax
                | c -> failwith $"Invalid category %c{c}"

            let updateMin category newMin range =
                match category with
                | 'x' -> { range with XMin = newMin }
                | 'm' -> { range with MMin = newMin }
                | 'a' -> { range with AMin = newMin }
                | 's' -> { range with SMin = newMin }
                | c -> failwith $"Invalid category %c{c}"

            let updateMax category newMax range =
                match category with
                | 'x' -> { range with XMax = newMax }
                | 'm' -> { range with MMax = newMax }
                | 'a' -> { range with AMax = newMax }
                | 's' -> { range with SMax = newMax }
                | c -> failwith $"Invalid category %c{c}"

            let rec split rules range =

                match rules with
                | Unconditional d ->
                    seq { range, d }

                | Conditional ({ Category = cat; Condition = LessThan i; Destination = d }, next) ->

                    let matching =
                        let oldMax = max cat range
                        let newMax = Math.Min(oldMax, i - 1)
                        range |> updateMax cat newMax

                    let nonMatching =
                        let oldMin = min cat range
                        let newMin = Math.Max(oldMin, i)
                        range |> updateMin cat newMin

                    seq { matching, d; yield! split next nonMatching }

                | Conditional ({ Category = cat; Condition = GreaterThan i; Destination = d }, next) ->

                    let matching =
                        let oldMin = min cat range
                        let newMin = Math.Max(oldMin, i + 1)
                        range |> updateMin cat newMin

                    let nonMatching =
                        let oldMax = max cat range
                        let newMax = Math.Min(oldMax, i)
                        range |> updateMax cat newMax

                    seq { matching, d; yield! split next nonMatching }

            let count range =
                ((range.XMax - range.XMin + 1) |> int64)
                * ((range.MMax - range.MMin + 1) |> int64)
                * ((range.AMax - range.AMin + 1) |> int64)
                * ((range.SMax - range.SMin + 1) |> int64)

        let acceptedRanges workflows =

            let rulesLookup = workflows |> Array.map (fun w -> w.Name, w.Rules) |> Map |> Collections.Generic.Dictionary

            let rec inner (range: RatingRange) =
                function
                | "A" -> seq { range }
                | "R" -> Seq.empty
                | workflowName ->
                    let rules = rulesLookup.Item workflowName
                    range |> RatingRange.split rules
                    |> Seq.collect (fun (r, n) -> inner r n)

            ({ XMin = 1; XMax = 4000; MMin = 1; MMax = 4000; AMin = 1; AMax = 4000; SMin = 1; SMax = 4000 }, "in")
            ||> inner
            |> Seq.sumBy RatingRange.count

        let solve text = text |> parse |> fst |> acceptedRanges

module Day20 =
    open System.Collections.Generic

    type Pulse =
        | LowPulse
        | HighPulse

    type FlipFlopModule =
        {
            IsOn: bool
        }

        member this.HandleInput =
            function
            | LowPulse ->
                let nowOn = not this.IsOn
                let output = if nowOn then HighPulse else LowPulse
                { IsOn = nowOn }, Some output
            | HighPulse  ->
                this, None


    type ConjunctionModule =
        {
            InputPulses: Map<string, Pulse>
        }

        member this.HandleInput connectionLabel pulse =
            let newInputs = this.InputPulses |> Map.add connectionLabel pulse

            let output =
                if newInputs |> Map.forall (fun _ pulse -> pulse = HighPulse) then
                    LowPulse
                else
                    HighPulse

            { InputPulses = newInputs },  output

    type Module =
        | FlipFlop of FlipFlopModule
        | Conjunction of ConjunctionModule
        | Broadcast

    module Module =

        let newFlipFlop = FlipFlop { IsOn = false }

        let newConjunction inputConnectionLabels =
            Conjunction { InputPulses = inputConnectionLabels |> Seq.map (fun l -> l, LowPulse) |> Map }

        let handleInput outputLabel pulse =
            function
            | FlipFlop ff ->
                let newState, output = ff.HandleInput pulse
                FlipFlop newState, output
            | Conjunction c ->
                let newState, output = c.HandleInput outputLabel pulse
                Conjunction newState, Some output
            | Broadcast ->
                Broadcast, Some pulse

    type Connection = {
        /// The label of the module whose output the connection attaches to.
        OutputLabel: string
        /// The label of the module whose input the connection attaches to.
        InputLabel: string
    }

    /// Given a configuration before a button press, returns the configuration after the pulses have stopped being
    /// sent, and a list of sent pulses that were sent paired with the connections that they were sent on.
    let handleButtonPress (configuration: Dictionary<string, Module * Connection array>) =

        let newConfig = Dictionary(configuration)

        let queue = Queue<Pulse * Connection>()

        let tryDequeue () =
            match queue.TryDequeue() with
            | true, item -> Some item
            | false, _ -> None

        queue.Enqueue(LowPulse, { OutputLabel = "button"; InputLabel = "broadcaster" })

        let signals =
            ()
            |> List.unfold (fun _ ->
                tryDequeue ()
                |> Option.map (fun item ->

                    let pulse, { OutputLabel = outputLabel; InputLabel = inputLabel } = item

                    newConfig.TryGet inputLabel
                    |> Option.iter (fun (module', outputConnections) ->

                        let module'', output = module' |> Module.handleInput outputLabel pulse

                        newConfig.[inputLabel] <- (module'', outputConnections)

                        output
                        |> Option.iter (fun output ->
                            outputConnections |> Array.iter (fun conn -> queue.Enqueue(output, conn))))

                    Some item, ()))
            |> List.choose id

        newConfig, signals

    let parse (lines: string array) =

        // Turn into more structured data.
        let data =
            lines
            |> Array.map (fun line ->
                let parts = line.Split(" -> ")
                let typeSignifier, moduleLabel =
                    match parts.[0].[0] with
                    | '%' -> Some '%', parts.[0].[ 1 .. ]
                    | '&' -> Some '&', parts.[0].[ 1 .. ]
                    | _ -> None, parts.[0]
                let outputConnectionLabels = parts.[1].Split(", ")
                moduleLabel, typeSignifier, outputConnectionLabels)

        // First pass to build up dictionary from module label to input labels.
        let toInputLabels =
            data
            |> Array.collect (fun (moduleLabel, _, outputConnectionLabels) ->
                outputConnectionLabels |> Array.map (fun outputLabel -> outputLabel, moduleLabel))
            |> Array.groupBy fst
            |> Seq.map (fun (k, vs) -> k, vs |> Array.map snd)
            |> Map
            |> Dictionary

        // Second pass to create config using map.
        let config =
            data
            |> Array.map (fun (moduleLabel, typeSignifier, outputConnectionLabels) ->

                let module' =
                    match typeSignifier with
                    | Some '%' -> Module.newFlipFlop
                    | Some '&' -> Module.newConjunction toInputLabels.[moduleLabel]
                    | Some _ -> failwith "Bug"
                    | None -> Broadcast

                let connections =
                    outputConnectionLabels |> Array.map (fun l -> { OutputLabel = moduleLabel; InputLabel = l })

                moduleLabel, (module', connections))
            |> Map
            |> Dictionary

        config, toInputLabels

    module PartOne =

        let handleNButtonPresses n config =

            let rec inner remaining config signals =

                if remaining = 0 then
                    config, signals |> Seq.toArray
                else
                    let newConfig, newSignals = config |> handleButtonPress
                    inner (remaining - 1) newConfig (Seq.append signals newSignals)

            inner n config Seq.empty

        let solve lines =

            let pulses = lines |> parse |> fst |> handleNButtonPresses 1000 |> snd |> Array.map fst

            pulses
            |> Seq.countBy id
            |> Seq.map snd
            |> Seq.reduce (*)

    module PartTwo =

        /// Returns the first index of a button press resulting in a low pulse being input to the module with the given
        /// label, provided that the first ten such indices are all divisible by the first.
        let lowPulseButtonPressIndexPatterns config label =

            let rec inner lowPulseIndices buttonPressCount config =

                let newConfig, signals = config |> handleButtonPress
                let newCount = buttonPressCount + 1

                let receivedLowPulse =
                    signals
                    |> List.exists (fun (pulse, connection) -> pulse = LowPulse && connection.InputLabel = label)

                match receivedLowPulse, lowPulseIndices |> List.length with
                | true, 9 ->
                    let inOrder = lowPulseIndices |> List.rev
                    let smallest = inOrder |> List.head
                    if inOrder |> List.forall (fun i -> i % smallest = 0) then
                        smallest
                    else
                        failwith $"Button press indices resulting in low pulses to %s{label} aren't cyclic: %A{inOrder}"
                | true, _ ->
                    inner (newCount :: lowPulseIndices) newCount newConfig
                | false, _ ->
                    inner lowPulseIndices newCount newConfig

            inner [] 0 config

        // Note: this solution isn't generic - it makes various assumptions about the input that are true for the input
        // that I have (and I suspect all inputs). If those assumptions do not hold, this function will fail with an
        // exception.
        let solve lines =

            let config, toInputLabels = lines |> parse

            let outputtingToRxLabel =
                match toInputLabels.["rx"] with
                | [| label |] -> label
                | labels -> failwith $"%A{labels} all output to rx, breaking assumption that there is only one."

            let outputtingToRxPredecessor =
                match config.[outputtingToRxLabel] with
                | Conjunction module', _ -> module'.InputPulses.Keys
                | _ -> failwith "The module outputting to rx is assumed to be a conjunction module."

            outputtingToRxPredecessor
            |> Seq.map (lowPulseButtonPressIndexPatterns config)
            |> Seq.map uint64
            |> Seq.reduce Math.lcm

module Day21 =

    let parse (lines: string array) =

        let startingPosition =
            lines
            |> Seq.mapi (fun row line -> row, line.IndexOf('S'))
            |> Seq.find (fun (_, col) -> col > -1)

        let map = lines |> array2D

        map, startingPosition

    /// Given a map and position, returns the garden plots in the map that are adjacent to that position.
    let adjacentGardenPlots map (row, col) =
        seq { row - 1, col; row, col - 1; row, col + 1; row + 1, col }
        |> Seq.filter (fun (r, c) ->
            r > -1
            && r < Array2D.length1 map
            && c > -1
            && c < Array2D.length2 map
            && Array2D.get map r c <> '#')

    /// Given a map and a position, returns an array of pairs whose first element is a distance from that position and
    /// whose second element is an array containing the positions that are garden plots at that distance from the
    /// given position.
    let plotsAtDistanceFrom maxDistance map position =

        let rec inner (previousDistance, _ as previousPlots, closerPlots) =

            let plotsWithDistances = (closerPlots, [| previousPlots |]) ||> Array.append

            let nextPlots =

                let plotsAtLowerDistances = plotsWithDistances |> Array.collect snd

                plotsAtLowerDistances
                |> Seq.collect (adjacentGardenPlots map)
                |> Seq.except plotsAtLowerDistances
                |> Seq.toArray

            if nextPlots |> Array.isEmpty || previousDistance = maxDistance then
                plotsWithDistances
            else
                inner (((previousDistance + 1), nextPlots), plotsWithDistances)

        inner ((0, [| position |]), [||])

    module PartOne =

        let solve targetSteps lines =

            let map, startingPosition = parse lines

            plotsAtDistanceFrom targetSteps map startingPosition
            // Can double back to get to plots with a lower distance where the difference is even.
            |> Array.filter (fun (distance, _) -> targetSteps - distance >= 0 && (targetSteps - distance) % 2 = 0)
            |> Array.collect snd
            |> Array.length

    /// Makes some simplifying assumptions, which apply to the puzzle input I have:
    /// - The edge rows and columns contain only garden plots.
    /// - The central rows and columns contain only garden plots.
    /// - The map is a square whose side length is odd.
    /// - The starting position is in the centre of the map.
    module PartTwo =

        let parse lines =

            let map, startingPosition = parse lines
            let h, w = map |> Array2D.length1, map |> Array2D.length2
            if h <> w then
                failwith $"Broken assumption: height %i{h} is not equal to width %i{w}."
            elif h % 2 = 0 then
                failwith $"Broken assumption: side length %i{h} is not odd."
            elif startingPosition <> (h / 2, w / 2) then
                failwith $"Broken assumption: starting position %A{startingPosition} is not in the centre of the map."
            else
                let expectedGardenPlots =
                    [| 0 .. h - 1 |]
                    |> Array.collect (fun row ->
                        if row = 0 || row = h / 2 || row = h - 1 then
                            [| 0 .. h - 1 |]
                        else
                            [|
                                // Left col
                                0

                                // Left diagonal
                                if row < h / 2 then
                                    h / 2 - row
                                else
                                    row - h / 2

                                // Middle col
                                h / 2

                                // Right diagonal
                                if row < h / 2 then
                                    h / 2 + row
                                else
                                    3 * (h / 2) - row

                                // Right col
                                h - 1
                            |]
                        |> Array.map (fun col -> row, col)
                    )

                match expectedGardenPlots |> Array.tryFind (fun (row, col) -> Array2D.get map row col = '#') with
                | Some (row, col) ->
                    failwith $"Broken assumption: (%i{row}, %i{col}) is not a garden plot."
                | None ->
                    map, startingPosition

        let solve targetSteps lines =
            printfn "Starting part two"

            let map, _ = parse lines
            /// How many plots are along a single edge of the map.
            let sideLength = map |> Array2D.length1
            /// Shortest distance from the start position to the map edge.
            let distanceToMapEdge = sideLength / 2

            /// A 5 x 5 grid of the original maps, used to calculate counts in various shapes that are repeated in
            /// larger grids.
            let bigMap, bigStartingPosition =

                let gridSize = 5
                let midpoint = 2 * sideLength + distanceToMapEdge

                let repeated (str: string) = String.Join("", Array.replicate gridSize str)
                [| for _ in 1 .. gridSize do yield! lines |> Array.map repeated |]
                |> Array.map (String.map (fun c -> if c = 'S' then '.' else c))
                |> Array.mapi (fun i s ->
                    if i = midpoint then
                        s |> String.mapi (fun j c -> if j = midpoint then 'S' else c)
                    else
                        s)
                |> parse

            let matchingPositions =
                plotsAtDistanceFrom (2 * sideLength + distanceToMapEdge) bigMap bigStartingPosition
                |> Array.collect (fun (d, positions) -> if (targetSteps - d) % 2 = 0 then positions else [||])

            let countInMap bigCoords =
                matchingPositions
                |> Array.sumBy (fun (row, col) -> if (row / sideLength, col / sideLength) = bigCoords then 1 else 0)

            /// Count in full maps where the matching positions are at an odd distance from the starting position.
            let oddFullMapCount = countInMap (2, 2) |> int64
            /// Count in full maps where the matching positions are at an even distance from the starting position.
            let evenFullMapCount = countInMap (2, 3) |> int64
            /// Count in maps at the corner of the square of positions at the target distance from the starting position.
            let oddCornerMapsCount = [| (0, 2); (2, 0); (2, 4); (4, 2) |] |> Array.sumBy countInMap |> int64
            /// Count in partial maps (along the side of the square) where the matching positions are at an odd distance
            /// from the starting position.
            let oddSideMapsCount = [| (1, 1); (1, 3); (3, 1); (3, 3) |] |> Array.sumBy countInMap |> int64
            /// Count in partial maps (along the side of the square) where the matching positions are at an even
            /// distance from the starting position.
            let evenSideMapCount = [| (1, 0); (1, 4); (3, 0); (3, 4) |] |> Array.sumBy countInMap |> int64

            // The number of maps beyond the central map in one direction.
            let n =
                let x = targetSteps - distanceToMapEdge
                match x % sideLength, x / sideLength with
                | 0, n when n % 2 = 1 -> failwith $"Expected n to be even, but is %i{n}"
                | 0, n -> n |> int64
                | _, _ -> failwith "Expected target distance to be the distance to a map edge."

            (n - 1L) * (n - 1L) * oddFullMapCount
            + n * n * evenFullMapCount
            + oddCornerMapsCount
            + (n - 1L) * oddSideMapsCount
            + n * evenSideMapCount

"./input/2023/day21"
|> System.IO.File.ReadAllLines
|> Day21.PartTwo.solve 26501365
