#r "nuget: FParsec"

open System

[<AutoOpen>]
module Util =

    [<RequireQualifiedAccess>]
    module Math =

        let integerPower base' exponent =
            if exponent < 0 then
                invalidArg (nameof(exponent)) $"exponent must be at least 0; given %i{exponent}"
            else
                Seq.replicate exponent base'
                |> Seq.fold (*) 1

        /// Returns the greatest common divisor of a and b.
        let gcd a b =
            // Implements Euclid's algorithm.
            let rec inner a b = if b = 0UL then a else inner b (a % b)
            inner a b

        /// Returns the least common multiple of a and b.
        let lcm a b = (a * b) / gcd a b

    [<RequireQualifiedAccess>]
    module Parser =
        open FParsec

        let runAndUnwrap f parser line =
            match CharParsers.run parser line with
            | Success (x, _, _) -> f x
            | Failure (error, _, _) -> failwith $"Failed to parse line (%s{error}): %s{line}"

    [<RequireQualifiedAccess>]
    module Seq =
        let containsRepeats xs = Seq.length (Seq.distinct xs) < Seq.length xs

        /// Returns a sequence up to and including the first element of the input sequence that matches the predicate,
        /// then no more. If there are no matching elements in the input sequence, then all elements will be returned.
        // Implementation inspired by https://stackoverflow.com/a/12564899
        // TODO: add tests.
        let takeUntilFirstMatch predicate (s:seq<_>) =
            let rec loop (en:System.Collections.Generic.IEnumerator<_>) = seq {
                if en.MoveNext() then
                    yield en.Current
                    if not (predicate en.Current) then
                        yield! loop en
            }

            seq {
                use en = s.GetEnumerator()
                yield! loop en
            }

        /// <summary>
        /// Keep generating elements by applying genNext to the previous element, starting with start, until an element
        /// that has already been encountered is generated.
        /// </summary>
        /// <returns>
        /// The subsequence before the repeated element is first encountered, and the subsequence starting from the
        /// first instance of the first repeated element and ending just before it is encountered again.
        /// </returns>
        /// <remarks>
        /// This is useful because it is easy from the returned information to calculate what the nth element will be
        /// without having to apply genNext n times, which is much more efficient if genNext is computationally
        /// expensive or n is very large.
        /// </remarks>
        // TODO: add tests, e.g. (fun n -> if n < 3 then n + 1 else n - 3) 13 should return [ 13; 10; 7; 4 ], [ 1; 2; 3; 0 ]
        let decomposeIntoPreCycleAndCycle genNext start =

            /// Note: elements are in reverse order.
            let untilFirstRepeat =
                ([ start ], Seq.initInfinite ignore)
                ||> Seq.scan
                    (fun previousElements ()  ->
                        if containsRepeats previousElements then
                            previousElements
                        else
                            // Later elements added to the start.
                            (previousElements |> List.head |> genNext) :: previousElements)
                |> Seq.skipWhile (not << containsRepeats)
                |> Seq.head

            let cycleStartElement, rest = List.head untilFirstRepeat, List.tail untilFirstRepeat

            let cycleRev, preCycleRev =
                let cycleRevStartIndex = rest |> List.findIndex ((=) cycleStartElement)
                List.splitAt (cycleRevStartIndex + 1) rest

            preCycleRev |> Seq.rev, cycleRev |> Seq.rev

        /// Returns a function that, given a non-negative integer `n`, gets the nth element of the sequence generated by
        /// repeated application of `genNext` starting with `start`, so long as that sequence eventually falls into a
        /// cycle.
        let repeatingSequenceElementCalculator genNext start =

            let preCycle, cycle =
                decomposeIntoPreCycleAndCycle genNext start
                |> fun (pc, c) -> Seq.toArray pc, Seq.toArray c

            fun n ->
                if n < preCycle.Length then preCycle.[n] else cycle.[ (n - preCycle.Length) % cycle.Length ]

    type Collections.Generic.IDictionary<'a, 'b> with

        member this.TryGet k =
            match this.TryGetValue k with
            | true, v -> Some v
            | false, _ -> None

    let memoize f =
        let cache = Collections.Generic.Dictionary<'key, 'value>()
        fun x -> cache.TryGet x |> Option.defaultWith (fun _ -> x |> f |> fun y -> cache.Add(x, y); y)

    [<RequireQualifiedAccess>]
    module Array2D =

        let row i array2D =
            seq { 0 .. (array2D |> Array2D.length2) - 1 }
            |> Seq.map (fun j -> Array2D.get array2D i j)
            |> Seq.toArray

        let column j array2D =
            seq { 0 .. (array2D |> Array2D.length1) - 1 }
            |> Seq.map (fun i -> Array2D.get array2D i j)
            |> Seq.toArray

        let columns array2D =
            seq { 0 .. (array2D |> Array2D.length2) - 1 }
            |> Seq.map (fun j -> column j array2D)
            |> Seq.toArray

module Day1 =
    module PartOne =
        let solve lines =
            let toCalibrationValue line =
                line
                |> String.filter Char.IsDigit
                |> fun cs -> Int32.Parse $"%c{Seq.head cs}%c{Seq.last cs}"

            lines
            |> Seq.sumBy toCalibrationValue
            |> fun totalCalibration -> printfn $"totalCalibration is %i{totalCalibration}"

    module PartTwo =
        let solve lines =
            let toCalibrationValue (line: string) =
                let digitRepresentations =
                    [
                        "0", 0
                        "1", 1
                        "2", 2
                        "3", 3
                        "4", 4
                        "5", 5
                        "6", 6
                        "7", 7
                        "8", 8
                        "9", 9
                        "one", 1
                        "two", 2
                        "three", 3
                        "four", 4
                        "five", 5
                        "six", 6
                        "seven", 7
                        "eight", 8
                        "nine", 9
                    ]

                let indices =
                    digitRepresentations
                    |> List.map (fun (rep, i) -> i, line.IndexOf rep, line.LastIndexOf rep)

                let firstDigit =
                    indices
                    |> List.filter (fun (_, first, _) -> first >= 0)
                    |> List.minBy (fun (_, first, _) -> first)
                    |> fun (i, _, _) -> i

                let lastDigit =
                    indices
                    |> List.filter (fun (_, last, _) -> last >= 0)
                    |> List.maxBy (fun (_, _, last) -> last)
                    |> fun (i, _, _) -> i

                10 * firstDigit + lastDigit

            lines
            |> Seq.sumBy toCalibrationValue
            |> fun totalCalibration -> printfn $"totalCalibration is %i{totalCalibration}"

module Day2 =
    open FParsec
    type Colour =
        | Red
        | Green
        | Blue

    type Set = {
        RedCount: int
        GreenCount: int
        BlueCount: int
    }

    module Set =
        let colourCount colour set =
            match colour with
            | Red -> set.RedCount
            | Green -> set.GreenCount
            | Blue -> set.BlueCount

    type Game =
        {
            GameId: int
            Sets: Set list
        }
        member this.MaxColourCount colour = this.Sets |> List.map (Set.colourCount colour) |> List.max
        member this.Power = this.MaxColourCount Red * this.MaxColourCount Green * this.MaxColourCount Blue

    let pGameId = pstring "Game " >>. pint32 .>> pstring ": "
    let pColour = stringReturn "red" Red <|> stringReturn "green" Green <|> stringReturn "blue" Blue
    let pColourCount = pint32 .>> pstring " " .>>. pColour
    let pSet = sepBy pColourCount (pstring ", ")
    let pGame = pGameId .>>. sepBy pSet (pstring "; ")
    let parse line =
        match CharParsers.run pGame line with
        | Success ((gameId, sets), _, _) ->
            let sets =
                sets
                |> List.map (fun colourCounts ->
                    let count colour =
                        colourCounts
                        |> List.tryFind (fun (_, c) -> c = colour)
                        |> Option.map fst
                        |> Option.defaultValue 0
                    {
                        RedCount = count Red
                        GreenCount = count Green
                        BlueCount = count Blue
                    })

            { GameId = gameId; Sets = sets }
        | Failure (error, _, _) ->
            failwith $"Failed to parse line (%s{error}): %s{line}"

    module PartOne =
        let solve lines =
            lines
            |> Seq.map parse
            |> Seq.filter (fun game ->
                game.MaxColourCount Red <= 12 &&
                game.MaxColourCount Green <= 13 &&
                game.MaxColourCount Blue <= 14)
            |> Seq.sumBy (fun game -> game.GameId)
            |> fun sumOfGameIds -> printfn $"Sum of game IDs: %i{sumOfGameIds}"

    module PartTwo =
        let solve lines =
            lines
            |> Seq.map parse
            |> Seq.sumBy (fun game -> game.Power)
            |> fun sumOfPowers -> printfn $"Sum of powers is %i{sumOfPowers}"

module Day3 =
    let matchingLocations predicate lines =
        lines
        |> Seq.indexed
        |> Seq.collect (fun (i, line) ->
            line
            |> Seq.indexed
            |> Seq.filter (snd >> predicate)
            |> Seq.map (fun (j, _) -> i, j))

    let numbersWithLocations lines =
        lines
        |> matchingLocations Char.IsDigit
        |> Seq.fold
            (fun (adjacentDigitLists, (lastI, lastJ)) (i,j) ->
                let adjacentDigitLists =
                    let digit = lines |> Seq.item i |> Seq.item j
                    if i = lastI && j = lastJ + 1 then
                        let digitsSoFar, previousNumbers =
                            match adjacentDigitLists with
                            | [] -> [], []
                            | soFar :: previous -> soFar, previous
                        ((digit, (i,j)) :: digitsSoFar) :: previousNumbers
                    else
                        [ (digit, (i,j)) ] :: adjacentDigitLists
                adjacentDigitLists, (i,j)
            )
            ([], (-1, 0))
        |> fst
        |> List.map (
            List.rev
            >> List.unzip
            >> (fun (digits, locations) -> digits |> List.toArray |> Int32.Parse, locations)
        )
        |> List.rev

    let locationsAdjacentTo (i, j) =
        seq {
            (i - 1, j - 1); (i - 1, j); (i - 1, j + 1)
            (i, j - 1);                 (i, j + 1)
            (i + 1, j - 1); (i + 1, j); (i + 1, j + 1)
        }

    module PartOne =
        let solve lines =
            let partNumbers =
                let locationsAdjacentToSymbols =
                    lines
                    |> matchingLocations (fun c -> Char.IsSymbol c || Char.IsPunctuation c && c <> '.')
                    |> Seq.collect locationsAdjacentTo
                    |> Set

                let isAdjacentToSymbol (_, locations) =
                    Set locations
                    |> Set.intersect locationsAdjacentToSymbols
                    |> Set.isEmpty
                    |> not

                lines
                |> numbersWithLocations
                |> List.filter isAdjacentToSymbol
                |> List.map fst

            List.sum partNumbers

    module PartTwo =
        let solve lines =
            let gearRatios =
                let numbersAroundEachAsterisk =
                    let numbersWithLocations = numbersWithLocations lines
                    lines
                    |> matchingLocations (fun c -> c = '*')
                    |> Seq.map (fun asteriskLocation ->
                        let locationsAdjacentToAsterisk = locationsAdjacentTo asteriskLocation |> Set
                        numbersWithLocations
                        |> List.filter (snd >> Set >> Set.intersect locationsAdjacentToAsterisk >> Set.isEmpty >> not)
                        |> List.map fst)

                numbersAroundEachAsterisk
                |> Seq.filter (fun numbers -> numbers.Length = 2)
                |> Seq.map (List.reduce (*))

            Seq.sum gearRatios

module Day4 =
    open FParsec

    type Card =
        {
            Number: int
            WinningNumbers: int Set
            NumbersYouHave: int Set
        }
        member this.MatchingNumberCount =
            Set.intersect this.WinningNumbers this.NumbersYouHave
            |> Set.count

    let pCardNumber = pstring "Card" >>. spaces1 >>. pint32 .>> pstring ":"
    // >>? results in lookahead behaviour, meaning that the '|' won't cause an error.
    // See http://www.quanttec.com/fparsec/users-guide/looking-ahead-and-backtracking.html
    let pNumbers = many (spaces1 >>? pint32)
    let pCard = pCardNumber .>>. pNumbers .>> pstring " |" .>>. pNumbers

    let parse line =
        match CharParsers.run pCard line with
        | Success (((cardNumber, winningNumbers), numbersYouHave), _, _) ->
            {
                Number = cardNumber
                WinningNumbers = Set winningNumbers
                NumbersYouHave =  Set numbersYouHave
            }
        | Failure (error, _, _) ->
            failwith $"Failed to parse line (%s{error}): %s{line}"

    module PartOne =
        let solve lines =
            lines
            |> Seq.map parse
            |> Seq.sumBy (fun card ->
                card.MatchingNumberCount
                |> fun count -> if count = 0 then 0 else Math.integerPower 2 (count - 1))

    module PartTwo =
        let solve lines =
            let contributions = Collections.Generic.Dictionary<int,int>()

            lines
            |> Seq.map parse
            // We can determine each card's contribution to the total by working out which copies it produces and using
            // the contributions of later cards. This means that if we go through the sequence backwards then we won't
            // have to keep track of the number of copies of each card, which should be simpler.
            |> Seq.rev
            |> Seq.sumBy (fun card ->
                let copyNumbers = Seq.init card.MatchingNumberCount (fun i -> card.Number + 1 + i)
                let contributionsFromCopies = copyNumbers |> Seq.sumBy (fun num -> contributions.Item num)
                let contribution = 1 + contributionsFromCopies

                contributions.Add(card.Number, contribution)

                contribution)

module Day5 =
    open FParsec

    type Range = {
        DestinationRangeStart: int64
        SourceRangeStart: int64
        RangeLength: int64
    }

    type MapHeader = {
        SourceCategory: string
        DestinationCategory: string
    }

    type Map = {
        Header: MapHeader
        Ranges: Range list
    }

    let pSpace = pchar ' '

    let pMapHeader =
        pipe2
            (many1 letter .>> pstring "-to-")
            (many1 letter .>> pSpace .>> pstring "map:")
            (fun letters letters' -> {
                SourceCategory = String(letters |> List.toArray)
                DestinationCategory = String(letters' |> List.toArray)
            })

    let pRange =
        pipe3 (pint64 .>> pSpace) (pint64 .>> pSpace) pint64 (fun i j k -> {
            DestinationRangeStart = i
            SourceRangeStart = j
            RangeLength = k
        })

    let pMap =
        pipe2
            pMapHeader
            (many (spaces >>? pRange))
            (fun header ranges -> { Header = header; Ranges = ranges })

    let mapsInOrder unorderedMaps =
        List.unfold
            (fun sourceCategory ->
                unorderedMaps
                |> List.tryFind (fun m -> m.Header.SourceCategory = sourceCategory)
                |> Option.map (fun map -> map, map.Header.DestinationCategory))
            "seed"

    let applyMap map (category, x) =
        if category = map.Header.SourceCategory then
            let applicableRange =
                map.Ranges
                |> List.tryFind (fun range ->
                    range.SourceRangeStart <= x && x < range.SourceRangeStart + range.RangeLength)

            match applicableRange with
            | Some range -> (map.Header.DestinationCategory, x + range.DestinationRangeStart - range.SourceRangeStart)
            | None -> (map.Header.DestinationCategory, x)
        else
            (category, x)

    module PartOne =
        type Almanac = {
            Seeds: int64 list
            Maps: Map list
        }

        let pSeeds = pstring "seeds:" >>. many (pSpace >>. pint64)

        let pFile = pipe2 pSeeds (many (spaces1 >>? pMap)) (fun seeds maps -> { Seeds = seeds; Maps = maps })

        let solve filePath =
            let almanac =
                match runParserOnFile pFile () filePath Text.Encoding.UTF8 with
                | Success (almanac, _, _) -> almanac
                | Failure (msg, _, _) -> failwith msg

            let applyAllMaps =
                almanac.Maps
                |> mapsInOrder
                |> List.map applyMap
                |> List.reduce (>>)

            almanac.Seeds
            |> List.map (fun i -> applyAllMaps ("seed", i))
            |> List.minBy snd

    module PartTwo =
        type SeedRange =
            {
                SeedRangeStart: int64
                SeedRangeLength: int64
            }
            member this.Seeds =
                seq { this.SeedRangeStart .. (this.SeedRangeStart + this.SeedRangeLength - 1L) }

        type Almanac = {
            SeedRanges: SeedRange list
            Maps: Map list
        }

        let pSeeds =
            pstring "seeds:"
            >>. many
                (pipe2
                    (pSpace >>. pint64)
                    (pSpace >>. pint64)
                    (fun i j -> { SeedRangeStart = i; SeedRangeLength = j }))

        let pFile = pipe2 pSeeds (many (spaces1 >>? pMap)) (fun seeds maps -> { SeedRanges = seeds; Maps = maps })

        let solve filePath =
            let almanac =
                match runParserOnFile pFile () filePath Text.Encoding.UTF8 with
                | Success (almanac, _, _) -> almanac
                | Failure (msg, _, _) -> failwith msg

            let applyAllMaps =
                almanac.Maps
                |> mapsInOrder
                |> List.map applyMap
                |> List.reduce (>>)

            almanac.SeedRanges
            |> Seq.collect (fun seedRange -> seedRange.Seeds)
            |> Seq.map (fun i -> applyAllMaps ("seed", i))
            |> Seq.minBy snd

module Day6 =
    open FParsec

    let numberOfChargeTimesThatExceedRecordDistance (timeAllowed, recordDistance: int64) =
        // If charge time is c and time allowed is t, then the distance travelled is c(t-c). It beats the record
        // distance r if c(t-c) > r. Expressed another way: c^2 - tc + r < 0; or (c - t/2)^2 < (t^2)/4 - r.
        // From this expression it can be seen that for any value of c which satisfies this inequality, a
        // different value of c which is at least as close to t/2 as c will also satisfy the inequality. Thus,
        // if we find the lowest positive integer value of c for which the inequality holds, c' (for which
        // c' - t/2 will be negative), c' + 2 * (t/2 - c') = t - c' will be the largest positive integer value
        // of c for which the inequality holds. There are therefore (t - c') - c' + 1 = t - 2c' + 1
        // possibilities for c satisfying the inequality.
        Seq.init timeAllowed (fun i -> (int64 i) * ((int64 timeAllowed) - (int64 i)) - recordDistance)
        |> Seq.findIndex (fun d -> d > 0)
        |> fun c -> timeAllowed - 2 * c + 1

    module PartOne =
        let solve (lines: string array) =
            let times = lines.[0] |> Parser.runAndUnwrap id (pstring "Time:" >>. many (spaces1 >>. pint32))
            let distances = lines.[1] |> Parser.runAndUnwrap id (pstring "Distance:" >>. many (spaces1 >>. pint64))

            (times, distances)
            ||> List.zip
            |> List.map numberOfChargeTimesThatExceedRecordDistance
            |> List.reduce (*)

    module PartTwo =
        let solve (lines: string array) =
            let timeAllowed = lines.[0] |> Seq.filter Char.IsDigit |> Seq.toArray |> String |> Int32.Parse
            let recordDistance = lines.[1] |> Seq.filter Char.IsDigit |> Seq.toArray |> String |> Int64.Parse

            numberOfChargeTimesThatExceedRecordDistance (timeAllowed, recordDistance)

module Day7 =

    type Label =
        | Two
        | Three
        | Four
        | Five
        | Six
        | Seven
        | Eight
        | Nine
        | Ten
        | Jack
        | Queen
        | King
        | Ace

    type Type' =
        | HighCard
        | OnePair
        | TwoPair
        | ThreeOfAKind
        | FullHouse
        | FourOfAKind
        | FiveOfAKind

    let parse (line: string) =
        let parts = line.Split(' ')
        let hand =
            let labels = parts.[0]
            let parseLabel i =
                labels
                |> Seq.item i
                |> function
                    | '2' -> Two
                    | '3' -> Three
                    | '4' -> Four
                    | '5' -> Five
                    | '6' -> Six
                    | '7' -> Seven
                    | '8' -> Eight
                    | '9' -> Nine
                    | 'T' -> Ten
                    | 'J' -> Jack
                    | 'Q' -> Queen
                    | 'K' -> King
                    | 'A' -> Ace
                    | c -> failwith $"Invalid label char '%c{c}'"
            parseLabel 0, parseLabel 1, parseLabel 2, parseLabel 3, parseLabel 4
        let bid = parts.[1] |> Int32.Parse
        hand, bid

    let solve classify rank lines =
        lines
        |> Array.map parse
        |> Array.sortBy (fun (l1, l2, l3, l4, l5 as hand, _) ->
            classify hand, (rank l1, rank l2, rank l3, rank l4, rank l5))
        |> Array.mapi (fun i (_, bid) -> bid * (i + 1))
        |> Array.sum

    module PartOne =

        let classify (label1, label2, label3, label4, label5) =
            let labels = [ label1; label2; label3; label4; label5 ]
            let labelCounts = labels |> List.map (fun label -> labels |> List.filter ((=) label) |> List.length)
            let hasOfAKind i = labelCounts |> List.contains i
            let numberOfPairs = labelCounts |> List.filter ((=) 2) |> List.length |> fun i -> i / 2
            match hasOfAKind 5, hasOfAKind 4, hasOfAKind 3, numberOfPairs with
            | true, _, _, _ -> FiveOfAKind
            | false, true, _, _ -> FourOfAKind
            | false, false, true, 1 -> FullHouse
            | false, false, true, 0 -> ThreeOfAKind
            | false, false, false, 2 -> TwoPair
            | false, false, false, 1 -> OnePair
            | false, false, false, 0 -> HighCard
            | _, _, _, _ -> failwith $"Invalid labels %A{labels}"

        let solve = solve classify id

    module PartTwo =

        let rank =
            function
            | Jack -> 1
            | Two -> 2
            | Three -> 3
            | Four -> 4
            | Five -> 5
            | Six -> 6
            | Seven -> 7
            | Eight -> 8
            | Nine -> 9
            | Ten -> 10
            | Queen -> 11
            | King -> 12
            | Ace -> 13

        let classify (label1, label2, label3, label4, label5) =
            let labels = [ label1; label2; label3; label4; label5 ]
            let nonJackLabels = labels |> List.filter ((<>) Jack)
            let nonJackLabelCounts =
                nonJackLabels |> List.map (fun label -> nonJackLabels |> List.filter ((=) label) |> List.length)

            let hasOfAKind i = nonJackLabelCounts |> List.contains i
            let numberOfPairs = nonJackLabelCounts |> List.filter ((=) 2) |> List.length |> fun i -> i / 2
            let numberOfJacks = 5 - List.length nonJackLabels

            match hasOfAKind 5, hasOfAKind 4, hasOfAKind 3, numberOfPairs, numberOfJacks with
            | true, _, _, _, _ -> FiveOfAKind
            | false, true, _, _, 1 -> FiveOfAKind
            | false, true, _, _, 0 -> FourOfAKind
            | false, false, true, 1, _ -> FullHouse
            | false, false, true, 0, 2 -> FiveOfAKind
            | false, false, true, 0, 1 -> FourOfAKind
            | false, false, true, 0, 0 -> ThreeOfAKind
            | false, false, false, 2, 1 -> FullHouse
            | false, false, false, 2, 0 -> TwoPair
            | false, false, false, 1, 3 -> FiveOfAKind
            | false, false, false, 1, 2 -> FourOfAKind
            | false, false, false, 1, 1 -> ThreeOfAKind
            | false, false, false, 1, 0 -> OnePair
            | false, false, false, 0, 5 -> FiveOfAKind
            | false, false, false, 0, 4 -> FiveOfAKind
            | false, false, false, 0, 3 -> FourOfAKind
            | false, false, false, 0, 2 -> ThreeOfAKind
            | false, false, false, 0, 1 -> OnePair
            | false, false, false, 0, 0 -> HighCard
            | _, _, _, _, _ -> failwith $"Invalid labels %A{nonJackLabels}"

        let solve = solve classify rank

module Day8 =

    type Direction =
        | Left
        | Right

    type Node = {
        Label: char * char * char
        LeftLabel: char * char * char
        RightLabel: char * char * char
    }

    let parse lines =

        let directions =
            lines
            |> Array.item 0
            |> Seq.map (function
                | 'L' -> Left
                | 'R' -> Right
                | c -> failwith $"Invalid direction $c{c}")

        let nodes =
            lines
            |> Seq.skip 2
            |> Seq.map (fun line ->
                match line |> Seq.toList with
                | c1 :: c2 :: c3 :: ' ' :: '=' :: ' ' :: '(' :: l1 :: l2 :: l3 :: ',' :: ' ' :: r1 :: r2 :: r3 :: [ ')' ] ->
                    {
                        Label = c1, c2, c3
                        LeftLabel = l1, l2, l3
                        RightLabel = r1, r2, r3
                    }
                | _ -> failwith $"Invalid line: %s{line}")

        directions |> Seq.toArray, nodes |> Seq.toArray

    module PartOne =

        let solve lines =

            let directions, nodes = parse lines

            let steps =
                let lookup = nodes |> Seq.map (fun n -> n.Label, n) |> dict
                let direction i = Array.item (i % directions.Length) directions
                Array.unfold
                    (fun (i, node) ->
                        match node.Label, direction i with
                        | ('Z', 'Z', 'Z'), _ -> None
                        | _, Left -> let n = lookup.Item node.LeftLabel in Some (n, (i + 1, n))
                        | _, Right -> let n = lookup.Item node.RightLabel in Some (n, (i + 1, n)))
                    (0, lookup.Item ('A', 'A', 'A'))

            steps.Length

    module PartTwo =

        type PathSignature = {
            /// The number of steps before the cycle starts.
            PreCycleLength: int
            /// The indices of steps before the cycle that correspond to nodes whose label ends in Z.
            PreCycleZIndices: int array
            /// The number of steps in the cycle.
            CycleLength: int
            /// The indices, relative to the cycle start, of steps within the cycle that correspond to nodes whose label
            /// ends in Z.
            CycleZIndices: int array
        }

        let solve lines =

            let directions, nodes = parse lines
            let nodeLookup = nodes |> Seq.map (fun n -> n.Label, n) |> dict

            let startNodes =
                nodes
                |> Array.filter (fun n -> match n.Label with _, _, 'A' -> true | _ -> false)

            /// For a given node, returns the nodes visited by starting there and following directions in order. Returns
            /// the last such node separately.
            let journeyLookup =
                let journey startNode =
                    let nodesVisited =
                        directions
                        |> Array.scan
                            (fun n d ->
                                match d with
                                | Left -> nodeLookup.Item n.LeftLabel
                                | Right -> nodeLookup.Item n.RightLabel)
                            startNode
                    nodesVisited.[0 .. (nodesVisited.Length - 2)], nodesVisited |> Array.last

                nodes
                |> Array.map (fun n -> n, journey n)
                |> dict

            // Keep repeating a journey (following all directions through once) until we end at a node that was the
            // start of a previous journey. Returns the nodes at the start of those journeys, and the node that is
            // repeated first.
            let journeyStartsUntilFirstRepeat startNode =

                let starts =
                    ([| startNode |], Seq.initInfinite ignore)
                    ||> Seq.scan
                        (fun previousStarts ()  ->
                            if Seq.containsRepeats previousStarts then
                                previousStarts
                            else
                                let previous = previousStarts |> Array.last
                                let _, nextStart = journeyLookup.Item previous
                                Array.append previousStarts [| nextStart |])
                    |> Seq.skipWhile (not << Seq.containsRepeats)
                    |> Seq.head

                starts |> Array.removeAt (starts.Length - 1), starts |> Array.last

            /// Returns the steps that are before a cycle starts, and a cycle of steps starting immediately afterwards
            /// that repeats forever.
            let decomposeFrom startNode =

                let journeyStarts, cycleStart = journeyStartsUntilFirstRepeat startNode

                let cycleStartIndex = journeyStarts |> Array.findIndex ((=) cycleStart)
                let preCycle =
                    journeyStarts
                    |> Array.take cycleStartIndex
                    |> Array.collect (fun n -> journeyLookup.Item n |> fst)
                let cycle =
                    journeyStarts
                    |> Array.skip cycleStartIndex
                    |> Array.collect (fun n -> journeyLookup.Item n |> fst)

                preCycle, cycle

            let pathSignatures =
                let isZNode n = match n.Label with _, _, 'Z' -> true | _ -> false

                startNodes
                |> Array.map (fun startNode ->
                    let preCycle, cycle = decomposeFrom startNode
                    {
                        PreCycleLength = preCycle.Length
                        PreCycleZIndices =
                            preCycle
                            |> Array.mapi (fun i n -> i, isZNode n)
                            |> Array.filter snd
                            |> Array.map fst
                        CycleLength = cycle.Length
                        CycleZIndices =
                            cycle
                            |> Array.mapi (fun i n -> i, isZNode n)
                            |> Array.filter snd
                            |> Array.map fst
                    })

            // TODO: implement in generic way.
            // This is a hack that makes use of some observations I've made about the particular input I have. It's not
            // sufficiently generic to handle every possible input of this type.
            //
            // The observations that I've made use of are:
            // - There are no pre-cycle z-indices
            // - The pre-cycles are all the same length
            // - There is only one cycle z-index, which is pre-cycle length away from the end of the cycle.
            //
            // As a result, any step index that is a z-index of a path must be divisible by that path signature's cycle
            // length. So a step index that is a z-index of all paths is divisible by all cycle lengths. The first such
            // step index is the least common multiple of the cycle lengths.
            pathSignatures
            |> Array.map (fun i -> i.CycleLength |> Convert.ToUInt64)
            |> Array.reduce Math.lcm

module Day9 =
    open FParsec

    let pLine: Parser<int32 list, unit> = sepBy pint32 (pchar ' ')

    let solve extrapolate lines =

        let histories =
            lines
            |> Array.map (Parser.runAndUnwrap List.toArray pLine)

        let differences numbers =
            numbers
            |> Seq.pairwise
            |> Seq.map (fun (i, j) -> j - i)

        // This doesn't include the final sequence of zeroes that are in the puzzle description; it seems easier to
        // work without them. It does include the input as the first element.
        let successiveDifferences ns =
            let differences =
                Array.unfold
                    (fun numbers ->
                        let diffs = differences numbers |> Seq.toArray
                        if diffs |> Array.forall ((=) 0) then
                            None
                        else
                            Some (diffs, diffs)
                    )
                    ns

            Array.append [| ns |] differences

        histories
        |> Array.map successiveDifferences
        |> Array.map extrapolate
        |> Array.sum

    module PartOne =

        let extrapolate successiveDifferences =
            (successiveDifferences |> Array.map Array.last, 0)
            ||> Array.foldBack (fun last deeperLast -> last + deeperLast)

        let solve = solve extrapolate

    module PartTwo =

        let extrapolate successiveDifferences =
            (successiveDifferences |> Array.map Array.head, 0)
            ||> Array.foldBack (fun first deeperFirst -> first - deeperFirst)

        let solve = solve extrapolate

module Day10 =
    open System.Collections.Generic

    type Direction =
        | North
        | South
        | East
        | West

    module Direction =

        let opposite =
            function
            | North -> South
            | South -> North
            | East -> West
            | West -> East

    type Tile =
        | Pipe of Direction * Direction
        | Ground
        | StartingPosition

    let pTile =
        function
        | '|' -> Pipe (North, South)
        | '-' -> Pipe (East, West)
        | 'L' -> Pipe (North, East)
        | 'J' -> Pipe (North, West)
        | '7' -> Pipe (South, West)
        | 'F' -> Pipe (South, East)
        | '.' -> Ground
        | 'S' -> StartingPosition
        | c -> failwith $"Invalid tile char: '%c{c}"

    [<RequireQualifiedAccess>]
    module Tile =

        /// The directions that the pipe on the tile (if any) exits to.
        let exitDirections tile =
            match tile with
            | Pipe (a, b) -> [| a; b |]
            | Ground
            | StartingPosition -> [||]

        /// Whether the pipe on the tile (if any) has an exit in the given direction.
        let exits direction tile = tile |> exitDirections |> Array.contains direction

    /// Parses lines into an array of pairs, whose first elements are coordinates and second elements are the contents
    /// of the tile at those coordinates.
    let parse lines =
        lines
        |> Array.mapi (fun i line -> line |> Seq.mapi (fun j c -> (i, j), pTile c) |> Seq.toArray)
        |> Array.collect id

    /// Returns the coordinates of the starting tile, and a dictionary from coordinates to the tile contents. The value
    /// corresponding to the starting coordinates is the pipe that is calculated to be present there, not
    /// StartingPosition.
    let calculateStartCoordsAndTileLookup tiles =
        let startCoords = tiles |> Array.find (snd >> (=) StartingPosition) |> fst
        let lookup = dict tiles

        let startPipe =
            let exitDirections = [
                let exits direction coords =
                    coords |> lookup.TryGet |> Option.map (Tile.exits direction) |> Option.defaultValue false

                let i, j = startCoords

                if (i - 1, j) |> exits South then North
                if (i + 1, j) |> exits North then South
                if (i, j + 1) |> exits West then East
                if (i, j - 1) |> exits East then West
            ]

            Pipe (exitDirections.[0], exitDirections.[1])

        startCoords, dict (Array.append tiles [| startCoords, startPipe |])

    /// Returns a sequence of pairs whose first element represents a distance from the starting position in the main
    /// loop, and whose second element is the set of the coordinates which correspond to tiles at that distance.
    let calculateCoordsByDistanceSeq startCoords (tileLookup: IDictionary<int * int, Tile>) =

        let startDirections = tileLookup.Item startCoords |> Tile.exitDirections

        let distanceGoingIn startDirection =

            ((startCoords, startDirection), Seq.initInfinite ignore)
            ||> Seq.scan (fun ((i, j), inDirection) _ ->
                let outDirection =
                    tileLookup.Item (i, j)
                    |> Tile.exitDirections
                    |> Array.find ((<>) inDirection)

                let nextCoords =
                    match outDirection with
                    | North -> (i - 1, j)
                    | South -> (i + 1, j)
                    | East -> (i, j + 1)
                    | West -> (i, j - 1)

                (nextCoords, outDirection |> Direction.opposite))
            |> Seq.map fst

        (distanceGoingIn startDirections.[0], distanceGoingIn startDirections.[1])
        ||> Seq.zip
        |> Seq.indexed
        // The paths are guaranteed to hit the midpoint of the loop at the same time because the length of the main loop
        // is even: the number of steps North equals the number of steps South, and likewise for East and West.
        |> Seq.takeUntilFirstMatch (fun (distance, (cs1, cs2)) -> distance <> 0 && cs1 = cs2)
        |> Seq.map (fun (distance, (cs1, cs2)) -> distance, Set (seq { cs1; cs2 }))

    module PartOne =

        let solve lines =
            parse lines
            |> calculateStartCoordsAndTileLookup
            ||> calculateCoordsByDistanceSeq
            |> Seq.last
            |> fst

    module PartTwo =

        // Consider the vertices of the square tiles that make up the grid.
        // The tiles which are not inside the loop are precisely those which have a vertex that can be reached by a path
        // starting from a vertex on the edge of the grid that traverses along sides that aren't crossed by the main
        // loop (which is to say that the main loop does not go directly between the two tiles that share the side).
        // To find all such vertices this function starts with the vertices at the edge of grid and iteratively adds
        // adjacent vertices that can be reached without crossing the main loop, until no new vertices are added.
        let solve lines =

            let startTileCoords, tileLookup = parse lines |> calculateStartCoordsAndTileLookup

            let rowCount = tileLookup.Keys |> Seq.map fst |> Seq.max
            let columnCount = tileLookup.Keys |> Seq.map snd |> Seq.max

            let mainLoopTileCoords =
                (startTileCoords, tileLookup)
                ||> calculateCoordsByDistanceSeq
                |> Seq.map snd
                |> Set.unionMany

            let accessibleAdjacentVertices (i, j) = seq {
                // Vertex (i, j) is a vertex of the tiles (i-1, j-1), (i-1, j), (i, j-1), (i, j) that are present in the
                // grid (edge vertices won't have four such tiles around them).
                // The adjacent vertices are (i-1, j), (i, j-1), (i, j+1) and (i+1, j).
                //                            Vertex (i-1, j)
                //                                 |
                //                                 v
                //                    x------------x------------x
                //                    | (i-1, j-1) | (i-1, j)   |
                // Vertex (i, j-1) -> x------------x------------x <- Vertex (i, j+1)
                //                    | (i, j-1)   | (i, j)     |
                //                    x------------x------------x
                //                                 ^
                //                                 |
                //                           Vertex (i+1, j)
                let tileI'J' = (i-1, j-1) |> fun cs -> cs, tileLookup.TryGet cs
                let tileI'J = (i-1, j) |> fun cs -> cs, tileLookup.TryGet cs
                let tileIJ' = (i, j-1) |> fun cs -> cs, tileLookup.TryGet cs
                let tileIJ = (i, j) |> fun cs -> cs, tileLookup.TryGet cs

                let connectedByMainLoop (((cs1, t1), d1), ((cs2, t2), d2)) =
                    mainLoopTileCoords |> Set.contains cs1
                    && mainLoopTileCoords |> Set.contains cs2
                    &&
                        (t1, t2)
                        ||> Option.map2 (fun t1 t2 -> t1 |> Tile.exits d1 && t2 |> Tile.exits d2)
                        |> Option.defaultValue false

                // Vertex (i-1, j) can be reached if there is no East-West pipe between tiles (i-1, j-1) and (i-1, j).
                if i > 0 && not (connectedByMainLoop ((tileI'J', East), (tileI'J, West))) then (i-1, j)

                // Vertex (i, j-1) can be reached if there is no North-South pipe between tiles (i-1, j-1) and (i, j-1).
                if j > 0 && not (connectedByMainLoop ((tileI'J', South), (tileIJ', North))) then (i, j-1)

                // Vertex (i, j+1) can be reached if there is no North-South pipe between tiles (i-1, j) and (i, j).
                if j < columnCount && not (connectedByMainLoop ((tileI'J, South), (tileIJ, North))) then (i, j+1)

                // Vertex (i+1, j) can be reached if there is no East-West pipe between tiles (i, j-1) and (i, j).
                if i < rowCount && not (connectedByMainLoop ((tileIJ', East), (tileIJ, West))) then (i+1, j)
            }

            let edgeVertices =
                Seq.allPairs (seq { 0 .. rowCount + 1 }) (seq { 0 .. columnCount + 1 }) |> Set
                |> Set.filter (fun (i, j) -> i = 0 || i = rowCount + 1 || j = 0 || j = columnCount + 1)

            let unenclosedVertices =
                // Start with the vertices at the edge of grid.
                ((Set.empty, edgeVertices), Seq.initInfinite ignore)
                // Iteratively add all adjacent vertices that can be reached without crossing the main loop
                ||> Seq.scan
                    (fun (oldVertices, newVertices) _ ->
                        let verticesSoFar = Set.union oldVertices newVertices
                        let nextVertices =
                            newVertices
                            |> Seq.collect accessibleAdjacentVertices
                            |> Set
                            |> fun s -> Set.difference s verticesSoFar
                        verticesSoFar, nextVertices)
                // Until no new vertices are added.
                |> Seq.takeWhile (snd >> Set.isEmpty >> not)
                |> Seq.last
                ||> Set.union

            let enclosedTileCoords =
                let allTileCoords = Seq.allPairs (seq { 0 .. rowCount }) (seq { 0 .. columnCount }) |> Set

                unenclosedVertices
                |> Seq.map (fun (i, j) -> Set (seq { (i-1, j); (i-1, j-1); (i, j-1); (i, j) }))
                |> Set.unionMany
                |> fun unenclosedTileCoords -> Set.difference allTileCoords unenclosedTileCoords

            enclosedTileCoords |> Set.count

module Day11 =

    type Pixel =
        | EmptySpace
        | Galaxy

    module Pixel =

        let parse = function '.' -> EmptySpace | '#' -> Galaxy | c -> failwith $"Invalid pixel: %c{c}"

    let solve expansionFactor image =

        let universe = image |> Array2D.map Pixel.parse

        let rowNumbers = [| 0 .. (universe |> Array2D.length1) - 1 |]
        let colNumbers = [| 0 .. (universe |> Array2D.length2) - 1 |]

        let galaxyIndices =
            Seq.allPairs rowNumbers colNumbers
            |> Seq.filter (fun (i, j) -> Array2D.get universe i j = Galaxy)
            |> Seq.toArray

        let galaxyPairs =
            galaxyIndices
            |> Seq.mapi (fun i g1 -> galaxyIndices.[ (i+1) .. ] |> Array.map (fun g2 -> g1, g2))
            |> Seq.collect id

        let emptyRowNumbers =
            rowNumbers
            |> Array.filter (fun i -> colNumbers |> Array.forall (fun j -> Array2D.get universe i j = EmptySpace))
            |> Set

        let emptyColNumbers =
            colNumbers
            |> Array.filter (fun j -> rowNumbers |> Array.forall (fun i -> Array2D.get universe i j = EmptySpace))
            |> Set

        let shortestPathLength ((i1: int, j1: int), (i2, j2)) =

            let crossedEmptyRows =
                (if i2 > i1 then Set (seq { i1 .. i2 }) else Set (seq { i2 .. i1 }))
                |> Set.intersect emptyRowNumbers
                |> Set.count
                |> int64

            let crossedEmptyCols =
                (if j2 > j1 then Set (seq { j1 .. j2 }) else Set (seq { j2 .. j1 }))
                |> Set.intersect emptyColNumbers
                |> Set.count
                |> int64

            (Math.Abs(i2 - i1) |> int64)
            + (Math.Abs (j2 - j1) |> int64)
            + (expansionFactor - 1L) * (crossedEmptyRows + crossedEmptyCols)

        galaxyPairs |> Seq.sumBy shortestPathLength

    module PartOne =
        let solve = solve 2


    module PartTwo =
        let solve = solve 1_000_000L

module Day12 =
    open System.Collections.Generic

    type SpringStatus =
        | Operational
        | Damaged
        | Unknown

    module SpringStatus =

        let parse =
            function '.' -> Operational | '#' -> Damaged | '?' -> Unknown | c -> failwith $"Invalid status char: %c{c}"

    type RowInfo = {
        Row: SpringStatus array
        DamagedGroupSizes: int array
    }

    module RowInfo =

        // Need to use the structural equality comparer to ensure that different arrays with the same contents are
        // considered to be the same key.
        let private cache = Dictionary<SpringStatus array * int array, int64>(HashIdentity.Structural)

        let countPossibleArrangements info =

            let groupDoesNotFitAtStartOf (statuses: SpringStatus array) groupSize =

                let groupIsTooBig = groupSize > statuses.Length
                let groupWouldIntersectOperationalSpring = statuses.[ .. groupSize - 1 ] |> Array.contains Operational
                let followingSpringIsDamaged =
                    statuses
                    |> Array.tryItem groupSize
                    |> Option.map ((=) Damaged)
                    |> Option.defaultValue false

                groupIsTooBig
                || groupWouldIntersectOperationalSpring
                || followingSpringIsDamaged

            let rec inner =
                function
                | [||], [||] ->
                    1L
                | [||], _ ->
                    0L
                | statuses, [||] ->
                    if statuses |> Array.contains Damaged then 0L else 1L
                | statuses, groupSizes ->

                    cache.TryGet (statuses, groupSizes)
                    |> Option.defaultWith (fun _ ->

                        let numberOfPossibleArrangements =

                            let countOperational () = inner (Array.tail statuses, groupSizes)

                            let countDamaged () =
                                let groupSize = Array.head groupSizes
                                if groupSize |> groupDoesNotFitAtStartOf statuses then
                                    0L
                                else
                                    inner (statuses.[ groupSize + 1 .. ], Array.tail groupSizes)

                            match Array.head statuses with
                            | Operational -> countOperational ()
                            | Damaged -> countDamaged ()
                            | Unknown -> countOperational () + countDamaged ()

                        cache.Add((statuses, groupSizes), numberOfPossibleArrangements)

                        numberOfPossibleArrangements)

            inner (info.Row, info.DamagedGroupSizes)

    let solve parse lines =
        lines
        |> Array.map (parse >> RowInfo.countPossibleArrangements)
        |> Array.sum

    module PartOne =

        let parseRowInfo (line: string) =
            let parts = line.Split(' ')
            {
                Row = parts.[0] |> Seq.map SpringStatus.parse |> Seq.toArray
                DamagedGroupSizes = parts.[1].Split(',') |> Array.map int
            }

        let solve = solve parseRowInfo

    module PartTwo =

        let parseRowInfo line =
            line
            |> PartOne.parseRowInfo
            |> fun { Row = row; DamagedGroupSizes = sizes } ->
                {
                    Row =
                        [| row; [| Unknown |]; row; [| Unknown |]; row; [| Unknown |]; row; [| Unknown |]; row |]
                        |> Array.collect id
                    DamagedGroupSizes =
                        sizes
                        |> Array.replicate 5
                        |> Array.collect id
                }

        let solve = solve parseRowInfo

module Day13 =

    module PartOne =

        let hasHorizontalLineOfSymmetryBeforeRow n pattern =

            let height = pattern |> Array2D.length1
            let numRowPairsToTest = Math.Min(height - 1 - n, n - 1)

            seq { 0 .. numRowPairsToTest }
            |> Seq.forall (fun i -> Array2D.row (n - 1 - i) pattern = Array2D.row (n + i) pattern)

        let hasVerticalLineOfSymmetryBeforeColumn n pattern =

            let width = pattern |> Array2D.length2
            let numColumnPairsToTest = Math.Min(width - 1 - n, n - 1)

            seq { 0 .. numColumnPairsToTest }
            |> Seq.forall (fun j -> Array2D.column (n - 1 - j) pattern = Array2D.column (n + j) pattern)

        let solve (text: string) =
            text.Split("\n\n")
            |> Array.map (fun patternStr ->
                patternStr.Split('\n') |> Array.filter (not << String.IsNullOrWhiteSpace) |> array2D)
            |> Array.map (fun pattern ->
                // Start at 1 because before row 0 would pass the test but have no reflected rows.
                seq { 1 .. Array2D.length1 pattern - 1 }
                |> Seq.tryFind (fun n -> pattern |> hasHorizontalLineOfSymmetryBeforeRow n)
                |> Option.map (fun n -> n * 100)
                |> Option.defaultWith (fun _ ->
                    seq { 1 .. Array2D.length2 pattern - 1 }
                    |> Seq.find (fun n -> pattern |> hasVerticalLineOfSymmetryBeforeColumn n)))
            |> Array.sum

    module PartTwo =

        let private hasExactlyOneFalse seq =
            seq
            // Generate running false total.
            |> Seq.scan (fun running testResult -> if testResult then running else running + 1) 0
            // Stop if running total reaches 2 (to avoid unnecessary work).
            |> Seq.takeUntilFirstMatch ((=) 2)
            |> Seq.last
            // It is a candidate if there is only one mismatch.
            |> (=) 1

        let hasSmudgedHorizontalLineOfSymmetryBeforeRow n pattern =

            let height, width = pattern |> Array2D.length1, pattern |> Array2D.length2
            let numRowPairsToTest = Math.Min(height - 1 - n, n - 1)

            seq { 0 .. numRowPairsToTest }
            // Generate sequence of results from testing whether corresponding elements across line being tested for
            // symmetry are equal.
            |> Seq.collect (fun i ->
                seq { 0 .. width - 1 }
                |> Seq.map (fun j -> Array2D.get pattern (n - 1 - i) j = Array2D.get pattern (n + i) j))
            |> hasExactlyOneFalse

        let hasSmudgedVerticalLineOfSymmetryBeforeColumn n pattern =

            let height, width = pattern |> Array2D.length1, pattern |> Array2D.length2
            let numColumnPairsToTest = Math.Min(width - 1 - n, n - 1)

            seq { 0 .. numColumnPairsToTest }
            // Generate sequence of results from testing whether corresponding elements across line being tested for
            // symmetry are equal.
            |> Seq.collect (fun j ->
                seq { 0 .. height - 1 }
                |> Seq.map (fun i -> Array2D.get pattern i (n - 1 - j) = Array2D.get pattern i (n + j)))
            |> hasExactlyOneFalse

        let solve (text: string) =
            text.Split("\n\n")
            |> Array.map (fun patternStr ->
                patternStr.Split('\n') |> Array.filter (not << String.IsNullOrWhiteSpace) |> array2D)
            |> Array.map (fun pattern ->
                // Start at 1 because before row 0 would pass the test but have no reflected rows.
                seq { 1 .. Array2D.length1 pattern - 1 }
                |> Seq.tryFind (fun n -> pattern |> hasSmudgedHorizontalLineOfSymmetryBeforeRow n)
                |> Option.map (fun n -> n * 100)
                |> Option.defaultWith (fun _ ->
                    seq { 1 .. Array2D.length2 pattern - 1 }
                    |> Seq.find (fun n -> pattern |> hasSmudgedVerticalLineOfSymmetryBeforeColumn n)))
            |> Array.sum

module Day14 =

    /// The new platform arrangement after tilting towards the start of all of the lines (so if lines are the
    /// columns, this tilts towards the top row).
    let tilt lineLength lines =

        lines
        |> Seq.map (fun col ->

            // Produce a sequence of pairs of the indices (counted from the northernmost row) where the boulders
            // stop and the number of boulders lined up from that point.
            let pairs =
                ([ (0, 0) ], col |> Seq.indexed)
                ||> Seq.fold (fun list (i, c) ->
                    match c, list with
                    | '.', (a, n) :: tail -> (a, n) :: tail
                    | 'O', (a, n) :: tail -> (a, n + 1) :: tail
                    | '#', list -> (i + 1, 0) :: list
                    | _, [] -> failwith "Bug: invalid state"
                    | c, _ -> failwith $"Column %A{col} has invalid character '%c{c}' in position %i{i}")
                |> Seq.filter (snd >> ((<>) 0))

            let roundIndices =
                (Seq.empty, pairs |> Seq.rev)
                ||> Seq.fold (fun state (i, n) -> seq {
                    yield! state
                    yield! seq { i .. i + n - 1 }
                })
                |> Set

            let cubeIndices = col |> Seq.indexed |> Seq.filter (snd >> ((=) '#')) |> Seq.map fst |> Set

            seq {
                for i in 0 .. lineLength - 1 do
                    if roundIndices |> Set.contains i then 'O'
                    elif cubeIndices |> Set.contains i then '#'
                    else '.'
            })

    let tiltNorth height rows = rows |> Seq.transpose |> tilt height |> Seq.transpose
    let tiltWest width rows = rows |> tilt width
    let tiltSouth height rows = rows |> Seq.transpose |> Seq.map Seq.rev |> tilt height |> Seq.map Seq.rev |> Seq.transpose
    let tiltEast width rows = rows |> Seq.map Seq.rev |> tilt width |> Seq.map Seq.rev

    let totalLoad rows =
        rows
        |> Seq.transpose
        |> Seq.collect (Seq.rev >> Seq.mapi (fun i x -> ((i + 1), x))  >> Seq.filter (snd >> ((=) 'O')) >> Seq.map fst)
        |> Seq.sum

    module PartOne =

        let solve lines =
            lines
            |> tiltNorth (Array.length lines)
            |> totalLoad

    module PartTwo =

        let spin height width rows =

            rows
            |> tiltNorth height
            |> tiltWest width
            |> tiltSouth height
            |> tiltEast width
            // Evaluate the sequences to avoid multiple evaluations when checking equality of elements.
            |> Seq.map Seq.toArray
            |> Seq.toArray

        let solve lines =

            let rows = lines |> Array.map Seq.toArray

            let elementCalculator =
                // TODO: explain why this falls into a cycle before one billion elements. It feels right, but I don't
                // have proof that it would for every possible puzzle input.
                Seq.repeatingSequenceElementCalculator
                    (spin (rows |> Array.length) (rows |> Array.head |> Array.length))
                    rows

            elementCalculator 1_000_000_000
            |> totalLoad

module Day15 =

    let steps initializationSequence = initializationSequence |> String.filter ((<>) '\n') |> fun s -> s.Split(',')

    let hash (input: char seq) = (0, input) ||> Seq.fold (fun currentValue c -> ((currentValue + (int c)) * 17 % 256))

    module PartOne =

        let solve initializationSequence = initializationSequence |> steps |> Array.map hash |> Array.sum

    module PartTwo =

        let solve initializationSequence =

            let boxes = Collections.Generic.Dictionary()
            for i in 0 .. 255 do
                boxes[i] <- [||]

            initializationSequence
            |> steps
            |> Seq.iter (fun step ->

                let span = step.AsSpan()

                let label = step |> Seq.take (span.LastIndexOfAny('-', '=')) |> Seq.toArray |> String
                let boxNumber = label |> hash
                let operationIndex = span.LastIndexOfAny('-', '=')

                match span.Item operationIndex with
                | '=' ->

                    let prevContents = boxes.Item boxNumber

                    let newContents =

                        let focalLength = span.Item (operationIndex + 1) |> string |> Int32.Parse

                        prevContents
                        |> Array.tryFindIndex (fst >> ((=) label))
                        |> Option.map (fun i -> prevContents |> Array.updateAt i (label, focalLength))
                        |> Option.defaultWith (fun _ -> Array.append prevContents [| (label, focalLength) |])

                    boxes[boxNumber] <- newContents

                | '-' ->
                    boxes.Item boxNumber
                    |> Array.filter (fst >> ((<>) label))
                    |> fun newContents -> boxes[boxNumber] <- newContents
                | c ->
                    failwith $"Invalid operation character %c{c}")

            (0, seq { 0 .. 255 })
            ||> Seq.fold (fun sum boxNumber ->
                let boxSum =
                    ((1, 0), boxes.[boxNumber])
                    ||> Array.fold (fun (slotNumber, boxSum) (_label, focalLength) ->
                        slotNumber + 1, boxSum + (boxNumber + 1) * slotNumber * focalLength)
                    |> snd
                sum + boxSum)

module Day16 =

    type Tile =
        | EmptySpace
        | FMirror
        | BMirror
        | HSplitter
        | VSplitter

    type Direction =
        | Upward
        | Downward
        | Leftward
        | Rightward

    type BeamSegment = {
        Row: int
        Col: int
        Direction: Direction
    }

    let parse lines =
        lines
        |> array2D
        |> Array2D.map (
            function
            | '.' -> EmptySpace
            | '/' -> FMirror
            | '\\' -> BMirror
            | '-' -> HSplitter
            | '|' -> VSplitter
            | c -> failwith $"Invalid tile char '%c{c}'")

    /// Returns a function that, given a segment, returns the segments that come next.
    let nextSegments layout =

        let height, width = layout |> Array2D.length1, layout |> Array2D.length2

        // Return anonymous function to avoid recalculation of height and width.
        fun segment ->

            let up =
                if segment.Row > 0 then
                    Some { segment with Row = segment.Row - 1; Direction = Upward }
                else
                    None
            let down =
                if segment.Row < height - 1 then
                    Some { segment with Row = segment.Row + 1; Direction = Downward }
                else
                    None
            let left =
                if segment.Col > 0 then
                    Some { segment with Col = segment.Col - 1; Direction = Leftward }
                else
                    None
            let right =
                if segment.Col < width - 1 then
                    Some { segment with Col = segment.Col + 1; Direction = Rightward }
                else
                    None

            match layout.[ segment.Row, segment.Col ], segment.Direction with
            | (EmptySpace | VSplitter), Upward -> [| up |]
            | (EmptySpace | VSplitter), Downward -> [| down |]
            | (EmptySpace | HSplitter), Leftward -> [| left |]
            | (EmptySpace | HSplitter), Rightward -> [| right |]
            | VSplitter, (Leftward | Rightward) -> [| up; down |]
            | HSplitter, (Upward | Downward) -> [| left; right |]
            | FMirror, Upward -> [| right |]
            | FMirror, Downward -> [| left |]
            | FMirror, Leftward -> [| down |]
            | FMirror, Rightward -> [| up |]
            | BMirror, Upward -> [| left |]
            | BMirror, Downward -> [| right |]
            | BMirror, Leftward -> [| up |]
            | BMirror, Rightward -> [| down |]
            |> Array.choose id

    /// A sequence whose nth element is an array of BeamSegments that the beam is in n steps after the startSegment.
    let steps layout startSegment =
        [| startSegment |]
        |> Seq.unfold (Array.collect (nextSegments layout) >> function [||] -> None | next -> Some (next, next))
        |> Seq.append (seq { [| startSegment |] })

    /// Returns a function that, given a BeamSegment, returns the path starting from it until it splits or leaves the
    /// grid. The path before the split or exit is returned as the first element of the pair; the second element
    /// contains the segments that come after the split or exit.
    let pathUntilSplitOrExit layout =

        fun startSegment ->

            startSegment
            |> steps layout
            |> Seq.takeUntilFirstMatch (Array.length >> ((<>) 1))
            |> Seq.toArray
            |> fun until ->
                let beforeSplitOrExit = until |> Array.take (until.Length - 1) |> Array.map Array.head
                let afterSplitOrExit = until |> Array.last
                beforeSplitOrExit, afterSplitOrExit

        |> memoize

    let countEnergizedTiles layout startSegment =

        let pathUntilSplitOrExit = pathUntilSplitOrExit layout

        let startSegments =
            (Set.empty, Set [ startSegment ])
            |> Seq.unfold
                (fun (oldStartSegments, startSegments) ->

                    let oldSegments = Set.union oldStartSegments startSegments

                    let newStartSegments =
                        startSegments
                        |> Set.map (pathUntilSplitOrExit >> snd >> set)
                        |> Set.unionMany
                        |> fun s -> Set.difference s oldSegments

                    if newStartSegments |> Set.isEmpty then
                        None
                    else
                        Some ((oldSegments |> Set.union newStartSegments, (oldSegments, newStartSegments))))
            |> Seq.last

        startSegments
        |> Set.map (fun x -> x |> pathUntilSplitOrExit |> fst |> Array.append [| x |] |> set)
        |> Set.unionMany
        |> Set.map (fun seg -> seg.Row, seg.Col)
        |> Set.count

    module PartOne =

        let solve lines = countEnergizedTiles (parse lines) { Row = 0; Col = 0; Direction = Rightward }

    module PartTwo =

        // TODO: speed up - takes about 15 seconds.
        let solve lines =

            let layout = parse lines

            seq {

                let height, width = layout |> Array2D.length1, layout |> Array2D.length2

                for i in 0 .. height - 1 do
                    { Row = i; Col = 0; Direction = Rightward }
                    { Row = i; Col = width - 1; Direction = Leftward }

                for j in 0 .. width - 1 do
                    { Row = 0; Col = j; Direction = Downward }
                    { Row = height - 1; Col = j; Direction = Upward }

            }
            |> Seq.map (countEnergizedTiles layout)
            |> Seq.max

// FSI process has to run in same directory as this .fsx file for the relative path to work correctly.
"./day16input"
|> System.IO.File.ReadAllLines
|> Day16.PartTwo.solve
