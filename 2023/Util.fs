[<AutoOpen>]
module Util

open System

[<RequireQualifiedAccess>]
module Math =

    let integerPower base' exponent =
        if exponent < 0 then
            invalidArg (nameof(exponent)) $"exponent must be at least 0; given %i{exponent}"
        else
            Seq.replicate exponent base'
            |> Seq.fold (*) 1

    /// Returns the greatest common divisor of a and b.
    let gcd a b =
        // Implements Euclid's algorithm.
        let rec inner a b = if b = 0UL then a else inner b (a % b)
        inner a b

    /// Returns the least common multiple of a and b.
    let lcm a b = (a * b) / gcd a b

[<RequireQualifiedAccess>]
module Parser =
    open FParsec

    let runAndUnwrap f parser line =
        match CharParsers.run parser line with
        | Success (x, _, _) -> f x
        | Failure (error, _, _) -> failwith $"Failed to parse line (%s{error}): %s{line}"

[<RequireQualifiedAccess>]
module Seq =

    let tryMin xs =
        if Seq.isEmpty xs then None else Some (Seq.min xs)

    let containsRepeats xs = Seq.length (Seq.distinct xs) < Seq.length xs

    /// Returns a sequence up to and including the first element of the input sequence that matches the predicate,
    /// then no more. If there are no matching elements in the input sequence, then all elements will be returned.
    // Implementation inspired by https://stackoverflow.com/a/12564899
    // TODO: add tests.
    let takeUntilFirstMatch predicate (s:seq<_>) =
        let rec loop (en:System.Collections.Generic.IEnumerator<_>) = seq {
            if en.MoveNext() then
                yield en.Current
                if not (predicate en.Current) then
                    yield! loop en
        }

        seq {
            use en = s.GetEnumerator()
            yield! loop en
        }

    /// <summary>
    /// Keep generating elements by applying genNext to the previous element, starting with start, until an element
    /// that has already been encountered is generated.
    /// </summary>
    /// <returns>
    /// The subsequence before the repeated element is first encountered, and the subsequence starting from the
    /// first instance of the first repeated element and ending just before it is encountered again.
    /// </returns>
    /// <remarks>
    /// This is useful because it is easy from the returned information to calculate what the nth element will be
    /// without having to apply genNext n times, which is much more efficient if genNext is computationally
    /// expensive or n is very large.
    /// </remarks>
    // TODO: add tests, e.g. (fun n -> if n < 3 then n + 1 else n - 3) 13 should return [ 13; 10; 7; 4 ], [ 1; 2; 3; 0 ]
    let decomposeIntoPreCycleAndCycle genNext start =

        /// Note: elements are in reverse order.
        let untilFirstRepeat =
            ([ start ], Seq.initInfinite ignore)
            ||> Seq.scan
                (fun previousElements ()  ->
                    if containsRepeats previousElements then
                        previousElements
                    else
                        // Later elements added to the start.
                        (previousElements |> List.head |> genNext) :: previousElements)
            |> Seq.skipWhile (not << containsRepeats)
            |> Seq.head

        let cycleStartElement, rest = List.head untilFirstRepeat, List.tail untilFirstRepeat

        let cycleRev, preCycleRev =
            let cycleRevStartIndex = rest |> List.findIndex ((=) cycleStartElement)
            List.splitAt (cycleRevStartIndex + 1) rest

        preCycleRev |> Seq.rev, cycleRev |> Seq.rev

    /// Returns a function that, given a non-negative integer `n`, gets the nth element of the sequence generated by
    /// repeated application of `genNext` starting with `start`, so long as that sequence eventually falls into a
    /// cycle.
    let repeatingSequenceElementCalculator genNext start =

        let preCycle, cycle =
            decomposeIntoPreCycleAndCycle genNext start
            |> fun (pc, c) -> Seq.toArray pc, Seq.toArray c

        fun n ->
            if n < preCycle.Length then preCycle.[n] else cycle.[ (n - preCycle.Length) % cycle.Length ]

type Collections.Generic.IDictionary<'a, 'b> with

    member this.TryGet k =
        match this.TryGetValue k with
        | true, v -> Some v
        | false, _ -> None

let memoize f =
    let cache = Collections.Generic.Dictionary<'key, 'value>()
    fun x -> cache.TryGet x |> Option.defaultWith (fun _ -> x |> f |> fun y -> cache.Add(x, y); y)

[<RequireQualifiedAccess>]
module Array2D =

    let row i array2D =
        seq { 0 .. (array2D |> Array2D.length2) - 1 }
        |> Seq.map (fun j -> Array2D.get array2D i j)
        |> Seq.toArray

    let column j array2D =
        seq { 0 .. (array2D |> Array2D.length1) - 1 }
        |> Seq.map (fun i -> Array2D.get array2D i j)
        |> Seq.toArray

    let columns array2D =
        seq { 0 .. (array2D |> Array2D.length2) - 1 }
        |> Seq.map (fun j -> column j array2D)
        |> Seq.toArray

